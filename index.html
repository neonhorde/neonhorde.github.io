<!DOCTYPE html>
<html>
    <head>
        <title>Neon Horde</title>
        <link rel = "icon" href = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT3SCKcLqkxDBbB5wbbWj68uiDLrOVblrO_rw&usqp=CAU">
    </head>
    <body style = "margin: 0 !important; padding: 0 !important">
        <canvas id = "gamescreen" style = "display:block; background-color: black;"></canvas>
    </body>
    <script>
        //change these variables to mess around slightly with game balancing. the only thing you should change are the numbers or changing false to true or vice versa
        //Note: don't delete the semi-colons. The lines should end with them.
        //the two below are cheat modes. god mode gives you a minigun and invincibility, power mode is only the minigun. Don't change chaos mode. It's bad... very bad.
        //note: powermode and godmode also act as 240 attack speed, but only once advanced coolant is active.
        var godMode = false;
        var powerMode = false; //powermode gives drones max attack speed regardless of their speed multi
        var chaosMode = false;
        var deathMode = false; //dont
        var devMode = false; //this is mostly just used for testing. starts you in the shop with a ton of coins, i just use it to test new items
        var gameMode = 0; //0 = standard, 1 = random, 2 = classic+
        //these mess with enemy scaling, should be self explanatory.
        var enemyHpPerWave = 1.75;
        var enemyDMGPerWave = 0.8;
        //these increase the strength of items
        var hpPerPoint = 4;
        var dmgPerPoint = 1.5;
        var moveSpeedPerPoint = 0.5; //Note: In game, this is shown as twice of whatever you put. This is just what it's using internally. Default 0.5 is shown as 1 in game.
        var attackSpeedPerPoint = 0.2; //Another note: This is shown in game as 10x whatever you put. 0.2 is 2 in game.
        var regenPerPoint = 1.5;
        var maxPoints = 9; //The amount of "points" items can spend to increase their stored stats
        var minPoints = 5;
        //change the price of the special items
        var gambleFirePrice = 2000;
        var smartFirePrice = 2500;
        var dashPrice = 1000;
        var dash2Price = 2000;
        var dash3Price = 3500;
        var multiShotPrice = 2500;
        var multiShot2Price = 3000;
        var multiShot3Price = 10000;
        var multiShot4Price = 75000;
        var statSpecialPrice = 750;
        var statSpecial2Price = 2000;
        var statSpecial3Price = 6000;
        var knockbackPrice = 1250;
        var shockwavePrice = 3000;
        var shockwave2Price = 4500;
        var shockwave2AltPrice = 4000;
        var retaliationPrice = 1000;
        var retaliation2Price = 2000;
        var goliathPrice = 4000;
        var totalityPrice = 12500;
        var sentinalAuraPrice = 50000;
        var regenPrice = 2000;
        var regen2Price = 4500;
        var stunPrice = 3500;
        var stun2Price = 4500;
        var stun2AltPrice = 7500;
        var bloodSacPrice = 1500;
        var bloodSac2Price = 3000;
        var bloodSac3Price = 4000;
        var regenBoostPrice = 2500;
        var leechPrice = 5000;
        var appraisalPrice = 3000;
        var damageBoostPrice = 5000;
        var freezeShotPrice = 750;
        var hardBulletPrice = 3000;
        var sharpBulletPrice = 15000;
        var extractPrice = 15000;
        var ultimaPrice = 60000;
        var coolantPrice = 15000;
        var cloakPrice = 2500;
        var cloak2Price = 5000;
        var refreshPrice = 7500;
        var servicesPrice = 3500;
        var droneBuffPrice = 1500;
        var sideDronePrice = 2000;
        var topDronePrice = 5000;
        var cornerDronePrice = 12000;
        var droneSeerPrice = 75000;
        var controllerPrice = 10000;
        var supplyPrice = 5000;
        var contingencyPrice = 4000;
        //these are base stats
        var bullSpeed = 20; //Normally unchangeable in game, if you want you can change it
        var attackSpeed = 10; //Decreasing this increases your attack speed. fires once every x frames, values below 0 do nothing extra.
        var playerSpeed = 6; //Again, shown as double this in game
        var maxHealth = 25;
        var damage = 5;
        var roundRegen = 0;
        var iFrames = 20; //how long you get invincibility for after hit. normally unchangable in game, and the time is equal to 20 milliseconds * the value of this. The default 20 equals 400 milliseconds, or 0.4 seconds.
        //more cheaty "base stats"
        var cyCoin = 0; //If you really want to cheat you can start with money i guess
        var gameState = 2; //2 = start menu (default), 0 = combat, 1 = shop, 3 = gameover. You could hypothetically set this to 1 and give yourself 300 cycoins, that would functionally skip wave 1 with no harm to yourself if you wanted to for some reason but idk man you do you
        //change these to start with one or more of the special items
        var smartFire = 0; //1 = gamblers gun, 2 = smartshot
        var summmitStar = false;
        var zenithFirestorm = false;
        var chaosCore = false;
        var doubleshot = false;
        var retaliationStage = 0; //1 = retaliation, 2 = destroyer armor, 3 = goliath armor, 4 = totality shield, 5 = sentinal aura
        var dash = 0; //1 = blink, 2 = plasmoid trail, 3 = burning destruction
        var knockback = false;
        var shockwave = 0; //1 = engine overload, 2 = pulse wave
        var shockwaveDamage = false;
        var stun = false;
        var stunDot = false; //enables/disables the damage over time effect unlocked by the arsenal variant of shockwave
        var bloodSac = 0; //1 = damage boost, 2 = attack speed boost
        var roundRegenMulti = 1; //multiplies end-of-round regen by this number. does not effect passive out-of-combat regen.
        var damageMulti = 1; //multiplier. 2 = 2x.
        var killHeal = 0; //restores x hp on kill.
        var freezeBullet = false;
        var hardBullet = false;
        var sharpBullet = false;
        var extractBullet = false;
        var ultimaBullet = false;
        var advancedCoolant = false;
        var cloak = false; //note, cloaking doesnt disable/reduce attack if you have powermode or godmode on
        var cloakAttack = false; //enables/disables your capability to attack while cloaked.
        var controllerMode = false; //toggles the controller buff of cloaking
        var refresh = false;
        var sideDrones = false; //note: pre-enabling the 3 regular drone upgrades and than purchasing them normally will duplicate them. this is intentional.
        var topDrones = false;
        var cornerDrones = false;
        var droneSeer = false;
        var contingency = false;
        var supplyDrops = false;
        //unique item stats. most are not changed in game
        var dashDelay = 75; //cooldown, lets you dash every x frames
        var dashDuration = 4; //how long the dash trail stays on screen. doesnt matter until you get plasmoid trail
        var dashDamageDivisor = 8; //lower = better. deals your damage divided by this number every frame an enemy is in the area of effect. dont set it to any lower than 3, as tier 3 dash lowers it by 2 and values 0 and under will break the game and cause it to deal either no damage or heal the enemies and uhhhh no
        var knockbackMulti = 0; //multiplies knockback by this number. does not apply to shockwave. is increased by 1 when knockback is enabled.
        var damageReduction = 1; //divides the damage you take by this number.
        var retaliationDamage = 4; //bullet damage/retaliation damage = damage dealt by retaliation. is halved by retaliation t2 and halved again by sentinal aura.
        var retaliationSize = 15; //lower = better. dont go below 8 else game will not like you when you try to upgrade retaliation naturally.
        var regen = 0; //what % of your regen you regen per second when out of combat.
        var stunLength = 100; //stun duration is equal to this number/50 in seconds. Default 100 = 2 seconds.
        var stunDelay = 700; //cooldown length is equal to this number divided by 50 in seconds. Default 700 = 14 second cooldown.
        var stunDamage = 75; //normally unchangeable in game. lower = better.
        var bloodCooldown = 500; //normally unchangeable in game. cooldown is equal to this nunmber divided by 50. Default 500 = 10 second cooldown.
        var bloodDuration = 250; //Duration is equal to this number divided by 50. Default 200 = 5 second duration.
        var bloodCost = 0.15; //This is the cost as labeled as a decimal. 0.15 = 15% hp cost.
        var freezeSpeed = 0.5; //normally unchangeable in game. multiplies the speed of the enemy by this when it has the freeze effect applied. lower = better.
        var freezeInterval = 3; //change this and the below 3 to reduce the interval of each special bullets rate. not changeable in game. dont set them to a decimal point, and keep in mind that the more advanced ones are prioritized over the less advanced ones.
        var hardInterval = 5;
        var sharpInterval = 20;
        var healInterval = 35;
        var healBulletHealAmount = 50;
        var ultimaInterval = 200;
        var shockwaveDamageMulti = 0.75; //the multiplier to your bullet damage that the alternate shockwave upgrade deals
        var cloakDelay = 500; //cooldown is equal to this number divided by 50 in seconds. default 500 = 10 seconds.
        var cloakDuration = 200; //duration is equal to this number divided by 50 in seconds. default 150 = 4 seconds.
        var refreshDelay = 1000; //you know the deal by now. default 1000 = 20 second cooldown.
        var cloakAttackMulti = 0.5; //multiplies your attack speed by this number while cloaked, but only if you have cloak attacking enabled
        var droneSpeed = 0.4;
        var seerSpeed = 40; //lower = better
        var seerCap = 20; //the max amount of drones drone overseer can summon
        var controllerSpeedMulti = 2;
        var itemCoinGain = 1;
        var contingencyUses = 0; //how many times a wave you can use conteingency call. each purchase of contingency adds 1 to this
        var contingencySpeed = 150; //lower = faster, why did i add this, not changeable in game
        var supplyHeal = 0; //multiplier of max hp. 0.03 = 3%. each purchase adds 0.03.
        //changes the scaling of the prices of generic purchases
        var itemScaling = 100;
        var healScaling = 75;
        var healBotAmount = 0.35;
        //end of code i reccomend that can safely be changed. changing code below this point may result in unintended side effects or prevent the game from working properly. do so at your own risk.
        const c = document.getElementById("gamescreen");
        const cx = c.getContext("2d");
        var wave = 1;
        var primeColor = "gray";
        var enemyPairs = 1;
        var health = maxHealth;
        var mutMin = 1;
        var mutMax = 1;
        var uniqueCap = 0;
        var originalDroneCount = 0;
        var laserActive = false;
        var updateColor = "red";
        var enemyPerWave = 10;
        var ml = 0;
        var supplyX = 0;
        var supplyY = 0;
        var currentControllerSpeedMulti = 1;
        if(devMode == true){
            gameState = 1;
            cyCoin += 10000000000000000000000;
        }
        const bullXMomentum = [];
        const bullYMomentum = [];
        const bullXPos = [];
        const bullYPos = [];
        const bulletProperties = [];
        const enemyHP = [];
        const enemyX = [];
        const enemyY = [];
        const enemyMulti = [];
        const enemyStatus = [];
        const droneX = [];
        const droneY = [];
        const droneType = [];
        const droneXTarget = [];
        const droneYTarget = [];
        let slot1 = [];
        let slot2 = [];
        let slot3 = [];
        let slot4 = [];
        let slot5 = [];
        let slot6 = [];
        let totalUniques = 0;
        let slotlengths = 0;
        function itemSetter(){
            switch(gameMode){
                case 0:
                    slot1 = [21];
                    slot2 = [22];
                    slot3 = [23];
                    slot4 = [24];
                    break;
                case 1:
                    let tempTotalItems = [6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 15, 61];
                    slot1 = [];
                    slot2 = [];
                    slot3 = [];
                    slot4 = [];
                    slot5 = [];
                    slot6 = [];
                    primeColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                    for(let i = 0; i < 16; i++){
                        let randomPick = Math.floor(Math.random() * tempTotalItems.length);
                        let randomSlot = Math.floor(Math.random() * 6 + 1);
                        switch(randomSlot){
                            case 1:
                                slot1.push(tempTotalItems[randomPick]);
                                break;
                            case 2:
                                slot2.push(tempTotalItems[randomPick]);
                                break;
                            case 3:
                                slot3.push(tempTotalItems[randomPick]);
                                break;
                            case 4:
                                slot4.push(tempTotalItems[randomPick]);
                                break;
                            case 5:
                                slot5.push(tempTotalItems[randomPick]);
                                break;
                            case 6:
                                slot6.push(tempTotalItems[randomPick]);
                                break;
                        }
                        tempTotalItems.splice(randomPick, 1);
                    }
                    break;
                case 2:
                    slot1 = [15, 40, 6, 7, 34, 27, 51, 8, 46, 9];
                    slot2 = [42, 18, 41, 17, 39, 59, 60, 28];
                    slot3 = [12, 10, 16, 19, 13, 20, 11, 14, 29];
                    slot4 = [25, 53, 26, 44, 49, 54, 58, 57, 56];
                    slot5 = [52, 43, 47, 35, 27, 36, 33, 37];
                    slot6 = [38, 48, 30, 32, 50, 31, 55, 45];
                    break;
            }
            totalUniques = slot1.length + slot2.length + slot3.length + slot4.length + slot5.length + slot6.length;
            slotlengths = [slot1.length, slot2.length, slot3.length, slot4.length, slot5.length, slot6.length];
        }
        itemSetter();
        var slotinspecting = 0;
        var enemyDMG =  enemyDMGPerWave * (wave + Math.max(0, wave - 9) * 0.75 + Math.max(0, wave- 19)) + 1.5;
        var playerSpeedX = 0;
        var playerSpeedY = 0;
        var healthBought = false;
        var randomShot;
        var stunCounter = 120;
        var dashStartX;
        var challengePoints = 0;
        var pause = false;
        var dashStartY;
        var contingencyAvailable = contingencyUses;
        var bloodDmgMulti = 1;
        var diagonalDash = false;
        var bloodSpeedMulti = 1;
        var dashEndX;
        var eHpMulti = 1;
        var eDmgMulti = 1;
        var moneyGain = 1;
        var eSpeedMulti = 1;
        var cloaked = false;
        var dashEndY;
        var cloakCounter = 0;
        var refreshCounter = 0;
        var menuInspecting = 0;
        var bloodCounter = 0;
        var shockwaveX;
        var stunCd = 700;
        var randomShotTarget;
        var bulletCycler = 0;
        var currentCloakSpeedMulti = 1;
        var shockwaveY;
        var shotDelay = 0;
        var enemyDelay = 18;
        var targetSwitch = true;
        var enemyCap = 30 + (wave - 1) * enemyPerWave;
        var shooting = false;
        var spawnDelay = 0;
        var enemies = 0;
        var kills = 0;
        var frameCounter = iFrames;
        var enemyCycler;
        var smartShotToggle = false;
        const laserY = [];
        var shopColor1;
        var shopColor2;
        var shopColor3;
        var shopPurchased = [];
        var shopHP = [];
        var shopDMG = [];
        var shopSpeed = [];
        var shopAttackSpeed = [];
        var shopRegen = [];
        var shopPrices = [];
        var totalKills = 0;
        var totalCoins = cyCoin;
        var shopRandomizer = 0;
        var inspecting = 0;
        var itemsPurchased = 0;
        var dashCd = 80;
        var shockwaveCd = 110;
        var autoFire = false;
        var summitCircler = 1;
        var startDelay = 0;
        var startCap = 0;
        var droneCounter = 0;
        var seerCounter = 0;
        if (wave >= 5){
            if(wave <= 20){
                mutMin += -0.25 -(wave - 5) * 0.025;
                mutMax += 0.5 -(wave - 5) * 0.05;
            } else{
                mutMin += -0.625;
                mutMax += 1.25;
            }
        }
        if((4 + wave/3) * eSpeedMulti > 15){
            var enemySpeed = 15;
        } else{
            var enemySpeed = 4 + wave/3;
        }
        if(deathMode == true){
            enemyPairs += 9;
        }
        if(dash > 1){
            dashDelay += -15;
            dashDuration += 16;
        }
        if(dash > 2){
            dashDuration = dashDuration * 2;
            dashDamageDivisor = 6;
        }
        if(knockback == true){
            knockbackMulti += 1;
        }
        if(gameState == 1){
            uniqueCap = totalUniques - uniqueCap;
        }
        if(retaliationStage > 1){
            retaliationSize += -3;
            retaliationDamage = retaliationDamage/2;
        }
        if(retaliationStage > 2){
            damageReduction += 1;
        }
        if(retaliationStage > 3){
            damageReduction += 2;
            retaliationSize += -4;
        }
        if(retaliationStage > 4){
            damageReduction += 2;
            retaliationDamage = retaliationDamage/2;
        }
        if(godMode == true){
            powerMode = true;
        }
        if(sideDrones == true){
            droneX.push(0);
            droneY.push(c.height/2 + ml/100);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            droneX.push(c.width - c.width/50);
            droneY.push(c.height/2 + ml/100);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            originalDroneCount += 2;
        }
        if(topDrones == true){
            droneX.push(c.width/2 + ml/100);
            droneY.push(0);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            droneX.push(c.width/2 + ml/100);
            droneY.push(c.height - c.height/25);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            originalDroneCount += 2;
        }
        if(cornerDrones == true){
            droneX.push(0);
            droneY.push(0);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            droneX.push(0);
            droneY.push(c.height - c.height/25);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            droneX.push(c.width - c.width/50);
            droneY.push(c.height - c.height/25);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            droneX.push(c.width - c.width/50);
            droneY.push(0);
            droneXTarget.push(0);
            droneYTarget.push(0);
            droneType.push(0);
            originalDroneCount += 4;
        }
        window.addEventListener("resize", resize, false);
        addEventListener("mousemove", shootStore, false);
        document.addEventListener("mousedown", playerShoot, false);
        document.addEventListener("mouseup", shootStop, false);
        document.addEventListener("touchmove", touchShoot, false);
        document.addEventListener("keydown", playerMove, false);
        document.addEventListener("keyup", playerStop, false);
        document.addEventListener("touchstart", startTouchShoot, false);
        document.addEventListener("touchend", touchShootEnd, false);
        document.addEventListener("visibilitychange", resize, false);
        function touchShootEnd(){
            shooting = false;
        }
        function startTouchShoot(){
            if(gameState != 2){
                shooting = true;
                mouseX = event.changedTouches[0].screenX;
                mouseY = event.changedTouches[0].screenY;
            } else{
                menuRunner();
            }
        }
        function menuRunner(){
            switch(menuInspecting){
                    case 1:
                        startDelay = enemyDelay;
                        itemSetter();
                        startCap = uniqueCap;
                        uniqueCap = totalUniques;
                        gameState = 0;
                        break;
                    case 2:
                        if(enemyDelay != 30){
                            enemyDelay++;
                            challengePoints += -20;
                        }
                        break;
                    case 3:
                        if(enemyDelay != 1){
                            enemyDelay--;
                            challengePoints += 20;
                        }
                        break;
                    case 4:
                        if(eDmgMulti > 0.2){
                            eDmgMulti += -0.1;
                            challengePoints += -8;
                        }
                        break;
                    case 5:
                        if(eDmgMulti < 3){
                            eDmgMulti += 0.1;
                            challengePoints += 8;
                        }
                        break;
                    case 6:
                        if(eHpMulti >= 0.4){
                            eHpMulti += -0.2;
                            challengePoints += -15;
                        }
                        break;
                    case 7:
                        if(eHpMulti <= 3){
                            eHpMulti += 0.2;
                            challengePoints += 15;
                        }
                        break;
                    case 8:
                        if(moneyGain > 0.6){
                            moneyGain += -0.1;
                            challengePoints += 12;
                        }
                        break;
                    case 9:
                        if(moneyGain < 2){
                            moneyGain += 0.1;
                            challengePoints += -12;
                        }
                        break;
                    case 10:
                        if(eSpeedMulti > 0.6){
                            eSpeedMulti += -0.1;
                            challengePoints += -10;
                        }
                        break;
                    case 11:
                        if(eSpeedMulti < 2){
                            eSpeedMulti += 0.1;
                            challengePoints += 10;
                        }
                        break;
                    case 13:
                        if(uniqueCap != 0){
                            uniqueCap--;
                            challengePoints += -15;
                        }
                        break;
                    case 12:
                        if(uniqueCap != 16){
                            uniqueCap++;
                            challengePoints += 15;
                        }
                        break;
                    case 14:
                        if(gameMode < 2){
                            gameMode++;
                        } else{
                            gameMode = 0;
                        }
                }
        }
        function playerShoot(){
            if(gameState != 2){
                shooting = true;   
            } else{
                menuRunner();
            }
        }
        function shopRando(){
            shopColor1 = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
            shopColor2 = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
            shopColor3 = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
            shopAttackSpeed = [0, 0, 0];
            shopRegen = [0, 0, 0];
            shopDMG = [0, 0, 0];
            shopHP = [0, 0, 0];
            shopSpeed = [0, 0, 0];
            shopPrices = [0, 0, 0];
            shopPurchased = [false, false, false];
            for(let t = 0; t < 3; t++){
                for(let i = 0; i < Math.floor(Math.random() * (maxPoints - minPoints) + minPoints); i++){
                    shopRandomizer = Math.floor(Math.random() * 5 + 1);
                    switch(shopRandomizer){
                        case 1:
                            shopHP[t] += hpPerPoint;
                            break;
                        case 2:
                            shopDMG[t] += dmgPerPoint;
                            break;
                        case 3:
                            shopSpeed[t] += moveSpeedPerPoint;
                            break;
                        case 4:
                            shopAttackSpeed[t] += attackSpeedPerPoint;
                            break;
                        case 5:
                            shopRegen[t] += regenPerPoint;
                            break;
                    }
                }
                shopPrices[t] = 100 + itemScaling * wave + (Math.floor(Math.random() * 5 + 1) * 10);
            }
        }
        shopRando();
        function shootStop(){
            shooting = false;
        }
        function playerMove(){
            switch(event.code){
                case "Escape":
                    if(pause == false && gameState == 0){
                        pause = true;
                        gameRenderer();
                    } else{
                        pause = false;
                    }
                    break
                case "KeyW":
                case "ArrowUp":
                    playerSpeedY = -playerSpeed;
                    break;
                case "KeyS":
                case "ArrowDown":
                    playerSpeedY = playerSpeed;
                    break;
                case "KeyA":
                case "ArrowLeft":
                    playerSpeedX = -playerSpeed;
                    break;
                case "KeyD":
                case "ArrowRight":
                    playerSpeedX = playerSpeed;
                    break;
                case "KeyQ":
                    if(autoFire == true){
                        autoFire = false;
                    } else{
                        autoFire = true;
                    }
                    break;
                case "KeyZ":
                    if(stun == true && stunCd >= stunDelay){
                        stunCounter = 0;
                        stunCd = 0;
                    }
                    break;
                case "KeyE":
                    if(smartFire != 0 && smartShotToggle == false){
                        smartShotToggle = true;
                    } else if (smartFire != 0){
                        smartShotToggle = false;
                    }
                    break;
                case "KeyX":
                    if(bloodSac != 0 && bloodCounter >= bloodCooldown && health > maxHealth * bloodCost && gameState == 0){
                        bloodDmgMulti = 2;
                        health += -maxHealth * bloodCost;
                        if(bloodSac > 1){
                            bloodSpeedMulti = 2;
                        }
                        bloodCounter = 0;
                    }
                    break;
                case "KeyF":
                    if(shockwave != 0 && shockwaveCd >= 100){
                        shockwaveCd = 0;
                        shockwaveX = playerX + c.width/80;
                        shockwaveY = playerY + c.width/80;
                        for(let i = 0; i < enemyX.length; i++){
                            if(Math.abs(enemyX[i] - playerX) + Math.abs(enemyY[i] - playerY) <= c.width/5 || shockwave > 1){
                                enemyX[i] += (enemyX[i] - playerX)/(Math.abs(enemyY[i] - playerY) + Math.abs(enemyX[i] - playerX)) * 500;
                                enemyY[i] += (enemyY[i] - playerY)/(Math.abs(enemyY[i] - playerY) + Math.abs(enemyX[i] - playerX)) * 500;
                                if(enemyY[i] < 0){
                                    enemyY[i] = 0;
                                } else if(enemyY[i] > c.height){
                                    enemyY[i] = c.height - c.height/20;
                                }
                                if(enemyX[i] < 0){
                                    enemyX[i] = 0;
                                } else if(enemyX[i] > c.width){
                                    enemyX[i] = c.width - c.height/20;
                                }
                                if(shockwaveDamage == true){
                                    enemyHP[i] += -damage * shockwaveDamageMulti;
                                    if(enemyHP[i] <= 0){
                                        kill(i);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case "KeyC":
                    if(cloak == true && cloakCounter > cloakDelay || cloak == true && controllerMode == true){
                        if(controllerMode == false){
                            cloaked = true;
                            if(cloakAttack == true){
                                currentCloakSpeedMulti = cloakAttackMulti;
                            } else{
                                currentCloakSpeedMulti = 0;
                            }
                        } else{
                            if(cloaked == true){
                                cloaked = false;
                                currentCloakSpeedMulti = 1;
                                currentControllerSpeedMulti = 1;
                            } else{
                                cloaked = true;
                                currentControllerSpeedMulti = controllerSpeedMulti;
                                if(cloakAttack == true){
                                    currentCloakSpeedMulti = cloakAttackMulti;
                                } else{
                                    currentCloakSpeedMulti = 0;
                                }
                            }
                        }
                        cloakCounter = 0;
                    }
                    break;
                case "KeyR":
                    if(refresh == true && refreshCounter > refreshDelay){
                        refreshCounter = 0;
                        skillRefresh();
                    }
                    break;
                case "KeyT":
                    if(contingencyAvailable != 0 && gameState == 0 && pause == false){
                        contingencyAvailable--;
                        laserY.push(0);
                    }
                    break;
                case "Space":
                    if(gameState == 3){
                        location.reload();
                    }
                    if(inspecting == 0){
                        if(dash > 0 && dashCd >= dashDelay && Math.abs(playerSpeedX) + Math.abs(playerSpeedY) > 0){
                            dashStartX = playerX + c.width/80;
                            dashStartY = playerY + c.width/80;
                            if(Math.abs(playerSpeedX) > 0 && Math.abs(playerSpeedY) > 0){
                                playerX += Math.sign(playerSpeedX) * ml/8;
                                playerY += Math.sign(playerSpeedY) * ml/8;
                                diagonalDash = true;
                            } else{
                                playerX += Math.sign(playerSpeedX) * ml/4;
                                playerY += Math.sign(playerSpeedY) * ml/4;
                                diagonalDash = false;
                            }
                            dashEndY = playerY + c.width/80;
                            dashEndX = playerX + c.width/80;
                            dashCd = 0;
                            if(playerY < 0){
                                playerY = 0;
                            } else if(playerY > c.height){
                                playerY = c.height - c.height/20;
                            }
                            if(playerX < 0){
                                playerX = 0;
                            } else if(playerX > c.width){
                                playerX = c.width - c.height/20;
                            }
                            frameCounter = iFrames/4;
                        } 
                    } else{
                        let purchase = false;
                        switch(inspecting){
                            case 1:
                            case 2:
                            case 3:
                                if(shopPrices[inspecting - 1] <= cyCoin && shopPurchased[inspecting - 1] == false){
                                        shopPurchased[inspecting - 1] = true;
                                        maxHealth += shopHP[inspecting - 1];
                                        health += shopHP[inspecting - 1];
                                        damage += shopDMG[inspecting - 1];
                                        if(playerSpeed + shopSpeed[inspecting - 1] > 30){
                                            playerSpeed = 30;
                                        } else{
                                            playerSpeed += shopSpeed[inspecting - 1];
                                        }
                                        if(attackSpeed - shopAttackSpeed[inspecting - 1] < 0 && advancedCoolant == false){
                                            attackSpeed = 0;
                                        } else if (advancedCoolant == true && attackSpeed - shopAttackSpeed[inspecting - 1] < -12){
                                            attackSpeed = -12;
                                        } else{
                                            attackSpeed += -shopAttackSpeed[inspecting - 1];
                                        }
                                        roundRegen += shopRegen[inspecting - 1];
                                        cyCoin += -shopPrices[inspecting - 1];
                                        itemsPurchased++;
                                    }
                                break;  
                            case 4:
                                if(cyCoin >= (healScaling * wave + 125) && healthBought == false && health != maxHealth){
                                    healthBought = true;
                                    cyCoin += -(healScaling * wave + 125);
                                    if(health + maxHealth * healBotAmount > maxHealth){
                                        health = maxHealth;
                                    } else{
                                        health += (maxHealth * healBotAmount);
                                    }
                                }
                                break;
                            case 5:
                                resume();
                                break;
                            case 6:
                                if(cyCoin >= multiShotPrice){
                                    cyCoin += -multiShotPrice;
                                    doubleshot = true;
                                    purchase = true;
                                }
                                break;
                            case 7:
                                if(cyCoin >= multiShot2Price){
                                    cyCoin += -multiShot2Price;
                                    chaosCore = true;
                                    purchase = true;
                                }
                                break;
                            case 8:
                                if(cyCoin >= multiShot3Price){
                                    cyCoin += -multiShot3Price;
                                    zenithFirestorm = true;
                                    purchase = true;
                                }
                                break;
                            case 9:
                                if(cyCoin >= multiShot4Price){
                                    cyCoin += -multiShot4Price;
                                    summmitStar = true;
                                    purchase = true;
                                }
                                break;
                            case 10:
                                if (gambleFirePrice <= cyCoin){
                                    cyCoin += -gambleFirePrice;
                                    if(smartFire < 1){
                                        smartFire = 1;
                                    }
                                    purchase = true;
                                }
                                break;
                            case 11:
                                if(smartFirePrice <= cyCoin){
                                    cyCoin += -smartFirePrice;
                                    smartFire = 2;
                                    purchase = true;
                                }
                                break;
                            case 12:
                                if(cyCoin >= dashPrice){
                                    cyCoin += -dashPrice;
                                    if(dash < 1){
                                        dash = 1;
                                    }
                                    dashCd = 0;
                                    purchase = true;
                                }
                                break;
                            case 13:
                                if(cyCoin >= dash2Price){
                                    cyCoin += -dash2Price;
                                    if(dash < 2){
                                        dash = 2;
                                    }
                                    dashDelay += -15;
                                    dashDuration += 16;
                                    purchase = true;
                                }
                                break;
                            case 14:
                                if(cyCoin >= dash3Price){
                                    cyCoin += -dash3Price;
                                    if(dash < 3){
                                        dash = 3;
                                    }
                                    dashDuration = dashDuration * 2;
                                    dashDamageDivisor += -2;
                                    purchase = true;
                                }
                                break;
                            case 15:
                                if(cyCoin >= statSpecialPrice){
                                    cyCoin += -statSpecialPrice;
                                    bullSpeed = bullSpeed * 2;
                                    purchase = true;
                                }
                                break;
                            case 16:
                                if(cyCoin >= statSpecial2Price){
                                    cyCoin += -statSpecial2Price;
                                    iFrames = iFrames * 1.5;
                                    purchase = true;
                                }
                                break;
                            case 17:
                                if(cyCoin >= statSpecial3Price){
                                    cyCoin += -statSpecial3Price;
                                    minPoints += 2;
                                    maxPoints += 3;
                                    purchase = true;
                                }
                                break;
                            case 18:
                                if(cyCoin >= knockbackPrice){
                                    cyCoin += -knockbackPrice;
                                    knockback = true;
                                    knockbackMulti += 1;
                                    purchase = true;
                                }
                                break;
                            case 19:
                                if(cyCoin >= shockwavePrice){
                                    shockwaveCd = 6;
                                    cyCoin += -shockwavePrice;
                                    if(shockwave < 1){
                                        shockwave = 1;
                                    }
                                    purchase = true;
                                }
                                break;
                            case 20:
                                if(cyCoin >= shockwave2Price){
                                    cyCoin += -shockwave2Price;
                                    shockwave = 2;
                                    purchase = true;
                                }
                                break;
                            case 25:
                                if(cyCoin >= retaliationPrice){
                                    cyCoin += -retaliationPrice;
                                    if(retaliationStage < 1){
                                        retaliationStage = 1;
                                    }
                                    purchase = true;
                                }
                                break;
                            case 26:
                                if(cyCoin >= retaliation2Price){
                                    cyCoin += -retaliation2Price;
                                    if(retaliationStage < 2){
                                        retaliationStage = 2;
                                    }
                                    retaliationSize += -3;
                                    retaliationDamage = retaliationDamage/2;
                                    purchase = true;
                                }
                                break;
                            case 27:
                                if(cyCoin >= goliathPrice){
                                    cyCoin += -goliathPrice;
                                    if(retaliationStage < 3){
                                        retaliationStage = 3;
                                    }
                                    damageReduction += 1;
                                    purchase = true;
                                }
                                break;
                            case 28:
                                if(cyCoin >= totalityPrice){
                                    cyCoin += -totalityPrice;
                                    if(retaliationStage < 4){
                                        retaliationStage = 4;
                                    }
                                    damageReduction += 2;
                                    retaliationSize += -4;
                                    purchase = true;
                                }
                                break;
                            case 29:
                                if(cyCoin >= sentinalAuraPrice){
                                    cyCoin += -sentinalAuraPrice;
                                    if(retaliationStage < 5){
                                        retaliationStage = 5;
                                    }
                                    damageReduction += 2;
                                    retaliationDamage = retaliationDamage/2;
                                    purchase = true;
                                }
                                break;
                            case 30:
                                if(cyCoin >= regenPrice){
                                    cyCoin += -regenPrice;
                                    regen += 4;
                                    purchase = true;
                                }
                                break;
                            case 31:
                                if(cyCoin >= regen2Price){
                                    cyCoin += -regen2Price;
                                    regen += 8;
                                    purchase = true;
                                }
                                break;
                            case 32:
                                if(cyCoin >= stunPrice){
                                    cyCoin += -stunPrice;
                                    stun = true;
                                    purchase = true; 
                                }
                                break;
                            case 33:
                                if(cyCoin >= stun2Price){
                                    cyCoin += -stun2Price;
                                    stunLength += 100;
                                    purchase = true; 
                                }
                                break;
                            case 34:
                                if(cyCoin >= stun2AltPrice){
                                    stunLength += -50;
                                    cyCoin += -stun2AltPrice;
                                    stunDot = true;
                                    purchase = true;
                                }
                                break;
                            case 35:
                                if(cyCoin >= bloodSacPrice){
                                    cyCoin += -bloodSacPrice;
                                    if(bloodSac < 1){
                                        bloodSac = 1;
                                    }
                                    purchase = true;
                                    bloodCounter = bloodCooldown + 1;
                                }
                                break;
                            case 36:
                                if(cyCoin >= bloodSac2Price){
                                    cyCoin += -bloodSac2Price;
                                    if(bloodSac < 2){
                                        bloodSac = 2;
                                    }
                                    purchase = true;
                                }
                                break;
                            case 37:
                                if(cyCoin >= bloodSac3Price){
                                    cyCoin += -bloodSac3Price;
                                    bloodCost += -0.05;
                                    bloodDuration += 100;
                                    purchase = true;
                                }
                                break;
                            case 38:
                                if(cyCoin >= regenBoostPrice){
                                    cyCoin += -regenBoostPrice;
                                    roundRegenMulti++;
                                    purchase = true;
                                }
                                break;
                            case 39:
                                if(cyCoin >= leechPrice){
                                    cyCoin += -leechPrice;
                                    killHeal += 0.5;
                                    purchase = true;
                                }
                                break;
                            case 40:
                                if(cyCoin >= appraisalPrice){
                                    cyCoin += -appraisalPrice;
                                    itemCoinGain = itemCoinGain * 1.25;
                                    purchase = true;
                                }
                                break;
                            case 41:
                                if(cyCoin >= damageBoostPrice){
                                    cyCoin += -damageBoostPrice;
                                    damageMulti += 0.25;
                                    purchase = true;
                                }
                                break;
                            case 42:
                                if(cyCoin >= freezeShotPrice){
                                    cyCoin += -freezeShotPrice;
                                    freezeBullet = true;
                                    purchase = true;
                                }
                                break;
                            case 43:
                                if(cyCoin >= hardBulletPrice){
                                    cyCoin += -hardBulletPrice;
                                    hardBullet = true;
                                    purchase = true;
                                }
                                break;
                            case 44:
                                if(cyCoin >= sharpBulletPrice){
                                    cyCoin += -sharpBulletPrice;
                                    sharpBullet = true;
                                    purchase = true;
                                }
                                break;
                            case 45:
                                if(cyCoin >= ultimaPrice){
                                    cyCoin += -ultimaPrice;
                                    bulletCycler = 0;
                                    ultimaBullet = true;
                                    purchase = true;
                                }
                                break;
                            case 46:
                                if(cyCoin >= coolantPrice){
                                    cyCoin += -coolantPrice;
                                    advancedCoolant = true;
                                    purchase = true;
                                }
                                break;
                            case 47:
                                if(cyCoin >= shockwave2AltPrice){
                                    cyCoin += -shockwave2AltPrice;
                                    shockwaveDamage = true;
                                    purchase = true;
                                }
                                break;
                            case 48:
                                if(cyCoin >= cloakPrice){
                                    cyCoin += -cloakPrice;
                                    cloak = true;
                                    cloakCounter = cloakDelay;
                                    purchase = true;
                                }
                                break;
                            case 49:
                                if(cyCoin >= refreshPrice){
                                    cyCoin += -refreshPrice;
                                    refresh = true;
                                    refreshCounter = refreshDelay;
                                    purchase = true;
                                }
                                break;
                            case 50:
                                if(cyCoin >= cloak2Price){
                                    cyCoin += -cloak2Price;
                                    cloakAttack = true;
                                    cloakCounter = cloakDelay;
                                    purchase = true;
                                }
                                break;
                            case 51:
                                if(cyCoin >= extractPrice){
                                    cyCoin += -extractPrice;
                                    extractBullet = true;
                                    purchase = true;
                                }
                                break;
                            case 52:
                                if(cyCoin >= servicesPrice){
                                    cyCoin += -servicesPrice;
                                    healScaling = healScaling * 0.5;
                                    healBotAmount += 0.15;
                                    purchase = true;
                                }
                                break;
                            case 57:
                                if(cyCoin >= droneBuffPrice){
                                    cyCoin += -droneBuffPrice;
                                    droneBuffPrice += 750;
                                    droneSpeed += 0.1;
                                    purchase = true;
                                }
                                break;
                            case 53:
                                if(cyCoin >= sideDronePrice){
                                    cyCoin += -sideDronePrice;
                                    droneX.push(0);
                                    droneY.push(c.height/2 + ml/100);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    droneX.push(c.width - c.width/50);
                                    droneY.push(c.height/2 + ml/100);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    originalDroneCount += 2;
                                    purchase = true;
                                }
                                break;
                            case 54:
                                if(cyCoin >= topDronePrice){
                                    cyCoin += -topDronePrice;
                                    droneX.push(c.width/2 + ml/100);
                                    droneY.push(0);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    droneX.push(c.width/2 + ml/100);
                                    droneY.push(c.height - c.height/25);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    originalDroneCount += 2;
                                    purchase = true;
                                    break;
                                }
                            case 55:
                                if(cyCoin >= cornerDronePrice){
                                    cyCoin += -cornerDronePrice;
                                    droneX.push(0);
                                    droneY.push(0);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    droneX.push(0);
                                    droneY.push(c.height - c.height/25);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    droneX.push(c.width - c.width/50);
                                    droneY.push(c.height - c.height/25);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    droneX.push(c.width - c.width/50);
                                    droneY.push(0);
                                    droneXTarget.push(0);
                                    droneYTarget.push(0);
                                    droneType.push(0);
                                    originalDroneCount += 4;
                                    purchase = true;
                                }
                                break;
                            case 56:
                                if(cyCoin >= droneSeerPrice){
                                    cyCoin += -droneSeerPrice;
                                    if(droneSeer == true){
                                        seerSpeed = seerSpeed * 0.5;
                                        seerCap = seerCap * 1.5;
                                    }
                                    droneSeer = true;
                                    purchase = true;
                                }
                                break;
                            case 58:
                                if(cyCoin >= controllerPrice){
                                    cyCoin += -controllerPrice;
                                    controllerMode = true;
                                    purchase = true;
                                }
                                break;
                            case 60:
                                if(cyCoin >= contingencyPrice){
                                    cyCoin += -contingencyPrice;
                                    contingencyUses++;
                                    purchase = true;
                                }
                                break;
                            case 59:
                                if(cyCoin >= supplyPrice){
                                    cyCoin += -supplyPrice;
                                    supplyDrops = true;
                                    supplyHeal += 0.03;
                                    purchase = true;
                                }
                                break;
                            case 61:
                                for(let t = 0; t < c.height/20; t++){
                                    for(let i = 0; i < c.width/20; i++){
                                        droneX.push(i * 20);
                                        droneY.push(t * 20);
                                        droneXTarget.push(0);
                                        droneYTarget.push(0);
                                        droneType.push(0);
                                        originalDroneCount++;
                                    }
                                }
                                purchase = true;
                                break;
                            //notes to self: item ids
                            //6-9: multishots
                            //10/11: smartfires
                            //12-14: dashes
                            //15-17: special stats
                            //18-20: knockbacks
                            //21-24: pacts
                            //25-29: armor/retaliation
                            //30-31: regen
                            //32-34: stun
                            //35-37: blood boosts
                            //38: regen booster
                            //39: leeching
                            //40: money
                            //41: damage booster
                            //42-45: special shots
                            //46: attack speed cap increase
                            //47 shockwave alt upgrade
                            //48: cloak
                            //49: refresh
                            //50: cloak attack
                            //51: extract bullet (i really should change ids this is horrific dear lord but its too much work (except its not))
                            //52: heal price reduction
                            //53-56: drones
                            //57: drone buff
                            //58: controller cloak
                            //59: supply drops
                            //60: contingency call
                            case 21:
                                primeColor = "red";
                                slot1 = [6, 7, 8, 9];
                                slot2 = [18, 19];
                                slot3 = [35, 36, 37];
                                slot4 = [32, 34];
                                slot5 = [15, 38, 41];
                                slot6 = [39, 40];
                                uniqueCap = startCap;
                                totalUniques = slot1.length + slot2.length + slot3.length + slot4.length + slot5.length + slot6.length;
                                slotlengths = [slot1.length, slot2.length, slot3.length, slot4.length, slot5.length, slot6.length];
                                uniqueCap = totalUniques - uniqueCap;
                                break;
                            case 22:
                                primeColor = "cyan";
                                slot1 = [12, 13, 14];
                                slot2 = [42, 43, 44, 51, 45];
                                slot3 = [15, 11];
                                slot4 = [19, 47];
                                slot5 = [48, 50];
                                slot6 = [49, 46];
                                uniqueCap = startCap;
                                totalUniques = slot1.length + slot2.length + slot3.length + slot4.length + slot5.length + slot6.length;
                                slotlengths = [slot1.length, slot2.length, slot3.length, slot4.length, slot5.length, slot6.length];
                                uniqueCap = totalUniques - uniqueCap;
                                break;
                            case 23:
                                primeColor = "orange";
                                slot1 = [15, 17];
                                slot2 = [40, 52];
                                slot3 = [53, 54, 55, 56];
                                slot4 = [57, 57, 57, 57];
                                slot5 = [59, 60];
                                slot6 = [48, 58];
                                uniqueCap = startCap;
                                totalUniques = slot1.length + slot2.length + slot3.length + slot4.length + slot5.length + slot6.length;
                                slotlengths = [slot1.length, slot2.length, slot3.length, slot4.length, slot5.length, slot6.length];
                                uniqueCap = totalUniques - uniqueCap;
                                break;
                            case 24:
                                primeColor = "green";
                                slot1 = [19, 20];
                                slot2 = [12, 16, 16];
                                slot3 = [15, 10];
                                slot4 = [25, 26, 27, 28, 29];
                                slot5 = [30, 31];
                                slot6 = [32, 33];
                                uniqueCap = startCap;
                                totalUniques = slot1.length + slot2.length + slot3.length + slot4.length + slot5.length + slot6.length;
                                slotlengths = [slot1.length, slot2.length, slot3.length, slot4.length, slot5.length, slot6.length];
                                uniqueCap = totalUniques - uniqueCap;
                                break;
                        }
                        if(purchase == true){
                            itemsPurchased++;
                            uniqueCap--;
                            switch(slotinspecting){
                                case 1:
                                    slot1.splice(0, 1);
                                    break;
                                case 2:
                                    slot2.splice(0, 1);
                                    break;
                                case 3:
                                    slot3.splice(0, 1);
                                    break;
                                case 4:
                                    slot4.splice(0, 1);
                                    break;
                                case 5:
                                    slot5.splice(0, 1);
                                    break;
                                case 6:
                                    slot6.splice(0, 1);
                                    break;
                            }
                        }   
                    }
                    break;
                event.preventDefault;
            }
        }
        function playerStop(){
            switch(event.code){
                case "KeyW":
                case "ArrowUp":
                case "KeyS":
                case "ArrowDown":
                    playerSpeedY = 0;
                    break;
                case "KeyA":
                case "ArrowLeft":
                case "KeyD":
                case "ArrowRight":
                    playerSpeedX = 0;
                    break;
            }
        }
        function enemySpawn(){
            switch(Math.floor(Math.random() * 4) + 1){
                case 1:
                    enemyX.push(0);
                    enemyY.push(Math.floor(Math.random() * c.height));
                    break;
                case 2:
                    enemyX.push(c.width - ml/80);
                    enemyY.push(Math.floor(Math.random() * c.height));
                    break;
                case 3:
                    enemyY.push(0);
                    enemyX.push(Math.floor(Math.random() * c.height));
                    break;
                case 4:
                    enemyY.push(c.height - ml/80);
                    enemyX.push(Math.floor(Math.random() * c.height));
                    break;
            }
            enemyMulti.push(Math.random() * (mutMax - mutMin) + mutMin)
            enemyHP.push(1 + ((wave + Math.max(0, (wave - 9)) * 0.75 + Math.max(0, wave - 19)) * enemyHpPerWave) * Math.pow(enemyMulti[enemyMulti.length - 1], 2) * eHpMulti);
            enemyStatus.push(0);
        }
        function resize(){
            let tempDroneX = [];
            let tempDroneY = [];
            let tempXDivide = c.width/playerX;
            let tempYDivide = c.height/playerY;
            for(let i  = 0; i < droneX.length; i++){
                tempDroneX.push(c.width/droneX[i]);
                tempDroneY.push(c.height/droneY[i]);
            }
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            playerX = c.width/tempXDivide;
            playerY = c.height/tempYDivide;
            ml = (c.width + c.height * 2)/2;
            if(pause == false && gameState == 0){
                pause = true;
            }
            for(let i  = 0; i < droneX.length; i++){
                droneX[i] = c.width/tempDroneX[i];
                droneY[i] = c.height/tempDroneY[i];
            }
            gameRenderer();
        }
        resize();
        var playerX = c.width/2 - ml/80;
        var playerY = c.height/2 - ml/80;
        var mouseX = c.width/2;
        var mouseY = c.height/2;
        function kill(enemyID){
            enemyX.splice(enemyID, 1);
            enemyY.splice(enemyID, 1);
            enemyHP.splice(enemyID, 1);
            enemyMulti.splice(enemyID, 1);
            enemyStatus.splice(enemyID, 1);
            cyCoin += Math.round((8 + wave * 2) * moneyGain * itemCoinGain);
            totalCoins += cyCoin - totalKills;
            kills++;
            totalKills++;
            enemies--;
            if(enemyID == randomShotTarget){
                targetSwitch = true;
            }
        }
        setInterval(function gameUpdate(){
            if(gameState != 3 && pause == false){
                for(let i = 0; i < bullXPos.length; i++){
                    bullXPos[i] += bullXMomentum[i] * bullSpeed * ml/1500;
                    bullYPos[i] += bullYMomentum[i] * bullSpeed * ml/1500;
                }
                for(let i = 0; i < laserY.length; i++){
                    laserY[i] += c.height/contingencySpeed;
                    if(laserY[i] >= c.height){
                        laserY.splice(i, 1);
                    }
                }
                for(var enemyCycler = 0; enemyCycler < enemyX.length; enemyCycler++){
                    let tempSpeedMulti = 1;
                    if(enemyStatus[enemyCycler] == 1){
                        tempSpeedMulti = 0.5;
                    }
                    if(dash > 1 && dashCd <= dashDuration){
                        if(enemyX[enemyCycler] + ml/40 + 10 > Math.min(dashStartX, dashEndX) && enemyX[enemyCycler] - ml/40 - 10 < Math.max(dashStartX, dashEndX) && enemyY[enemyCycler] + ml/40 + 10 > Math.min(dashStartY, dashEndY) && enemyY[enemyCycler] - ml/40 - 10 < Math.max(dashStartY, dashEndY) && diagonalDash == false || diagonalDash == true && enemyX[enemyCycler] + ml/40 + 10 > Math.min(dashStartX, dashEndX) && enemyX[enemyCycler] - ml/40 - 10 < Math.max(dashStartX, dashEndX) && Math.abs(enemyX[enemyCycler] - dashStartX) * Math.sign(dashEndY - dashStartY) + ml/30 > enemyY[enemyCycler] - dashStartY && Math.abs(enemyX[enemyCycler] - dashStartX) * Math.sign(dashEndY - dashStartY) - ml/30 < enemyY[enemyCycler] - dashStartY){
                            enemyHP[enemyCycler] += -damage/dashDamageDivisor * bloodDmgMulti * damageMulti;
                            if(enemyHP[enemyCycler] <= 0){
                                kill(enemyCycler);
                            }
                        }
                    }
                    for(let i = 0; i < laserY.length; i++){
                        if(enemyY[enemyCycler] + ml/40 > laserY[i] && enemyY[enemyCycler] < laserY[i] + c.height/10){
                            kill(enemyCycler);
                        }   
                    }
                    if(enemyX[enemyCycler] < playerX + ml/40 && enemyX[enemyCycler] + ml/40 > playerX && enemyY[enemyCycler] < playerY + ml/40 && enemyY[enemyCycler] + ml/40 > playerY && frameCounter >= iFrames && godMode == false && cloaked == false || controllerMode == true && godMode == false && enemyX[enemyCycler] < playerX + ml/40 && enemyX[enemyCycler] + ml/40 > playerX && enemyY[enemyCycler] < playerY + ml/40 && enemyY[enemyCycler] + ml/40 > playerY && frameCounter >= iFrames){
                        frameCounter = 0;
                        health += -(enemyDMG * enemyMulti[enemyCycler] * eDmgMulti)/damageReduction;
                        kill(enemyCycler);
                        if(health <= 0){
                            health = 0;
                            gameState = 3;
                        } else if(retaliationStage != 0){
                            for(let i = 0; i < enemyX.length; i++){
                                if(Math.abs(enemyX[i] - playerX) + Math.abs(enemyY[i] - playerY) - ml/30 <= ml/retaliationSize){
                                    enemyHP[i] += -damage/retaliationDamage * damageMulti * bloodDmgMulti;
                                    if(enemyHP[i] <= 0){
                                        kill(enemyCycler)
                                    }
                                }
                            }
                        }
                    }
                    for(let i = 0; i < bullXPos.length; i++){
                        if(bullXPos[i] < enemyX[enemyCycler] + ml/40 && bullXPos[i] + ml/100 > enemyX[enemyCycler] && bullYPos[i] < enemyY[enemyCycler] + ml/40 && bullYPos[i] + ml/100 > enemyY[enemyCycler]){
                            enemyHP[enemyCycler] += -damage * bloodDmgMulti * damageMulti;
                            if(bulletProperties[i] == 5){
                                if(health + healBulletHealAmount >= maxHealth){
                                    health = maxHealth;
                                } else{
                                    health += healBulletHealAmount;
                                }
                            }
                            if(enemyHP[enemyCycler] <= 0 || bulletProperties[i] == 2 || bulletProperties[i] == 3){
                                kill(enemyCycler);
                                if(health + killHeal <= maxHealth){
                                    health += killHeal;
                                } else{
                                    health = maxHealth;
                                }
                            } else{
                                enemyX[enemyCycler] += bullXMomentum[i] * bullSpeed * 3 * knockbackMulti;
                                enemyY[enemyCycler] += bullYMomentum[i] * bullSpeed * 3 * knockbackMulti;
                                if(enemyStatus[enemyCycler] != 1){
                                    enemyStatus[enemyCycler] = bulletProperties[i];
                                }
                            }
                            if(bulletProperties[i] != 3){
                                bullXPos.splice(i, 1);
                                bullYPos.splice(i, 1);
                                bullXMomentum.splice(i, 1);
                                bullYMomentum.splice(i, 1);
                                bulletProperties.splice(i, 1);
                            }
                        }
                    }
                    if(stunCounter > stunLength && cloaked == false || controllerMode == true && stunCounter > stunLength){
                        enemyX[enemyCycler] += (playerX - enemyX[enemyCycler])/(Math.abs(playerY - enemyY[enemyCycler]) + Math.abs(playerX - enemyX[enemyCycler])) * enemySpeed/enemyMulti[enemyCycler] * eSpeedMulti * ml/1300 * tempSpeedMulti;
                        enemyY[enemyCycler] += (playerY - enemyY[enemyCycler])/(Math.abs(playerY - enemyY[enemyCycler]) + Math.abs(playerX - enemyX[enemyCycler])) * enemySpeed/enemyMulti[enemyCycler] * eSpeedMulti * ml/1300 * tempSpeedMulti;
                    } else if (stunDot == true && stunCounter < stunLength){
                        enemyHP[enemyCycler] += -damage/stunDamage * bloodDmgMulti * damageMulti;
                        if(stunCounter % 2 == 0){
                            enemyX[enemyCycler] += ml/500;
                        } else{
                            enemyX[enemyCycler] += -ml/500;
                        }
                        if(enemyHP[enemyCycler] <= 0){
                            kill(enemyCycler);
                        }
                    }
                }
                if(shotDelay * bloodSpeedMulti * currentCloakSpeedMulti > attackSpeed && shooting == true || powerMode == true && shooting == true || shotDelay * bloodSpeedMulti * currentCloakSpeedMulti > attackSpeed && autoFire == true || powerMode == true && autoFire == true){
                    shoot();
                    if(advancedCoolant == true && attackSpeed * bloodSpeedMulti * currentCloakSpeedMulti == -12 || powerMode == true && advancedCoolant == true){
                        shoot();
                    }
                    shotDelay = 0;
                }
                if(droneCounter * droneSpeed * currentControllerSpeedMulti * bloodSpeedMulti > attackSpeed && gameState == 0 || powerMode == true && gameState == 0){
                    droneShooter();
                    droneCounter = 0;
                }
                if(spawnDelay > enemyDelay && gameState == 0 && enemies < 100 + 25 * Math.floor(wave/10)){
                    spawnDelay = 0;
                    for(let i = 0; i < enemyPairs; i++){
                        enemies++;
                        enemySpawn();
                    }
                }
                if(gameState == 0 && kills >= enemyCap){
                    gameState = 1;
                    skillRefresh();
                    laserY.length = 0;
                    autoFire = false;
                    enemyHP.length = 0;
                    enemyX.length = 0;
                    enemyY.length = 0;
                    enemyMulti.length = 0;
                    enemyStatus.length = 0;
                    bullXPos.length = 0;
                    bullYPos.length = 0;
                    bullXMomentum.length = 0;
                    bullYMomentum.length = 0;
                    droneX.splice(originalDroneCount, droneX.length - originalDroneCount);
                    droneY.splice(originalDroneCount, droneY.length - originalDroneCount);
                    droneXTarget.splice(originalDroneCount, droneXTarget.length - originalDroneCount);
                    droneYTarget.splice(originalDroneCount, droneYTarget.length - originalDroneCount);
                    droneType.splice(originalDroneCount, droneType.length - originalDroneCount);
                    kills = 0;
                    enemies = 0;
                    playerX = c.width/2 - ml/80;
                    playerY = c.height/2 - ml/80;
                    healthBought = false;
                    shopRando();
                }
                if(gameState == 0 && seerCounter > seerSpeed && droneSeer == true && droneX.length - originalDroneCount < seerCap){
                    seerCounter = 0;
                    droneX.push(playerX);
                    droneY.push(playerY);
                    droneXTarget.push(0);
                    droneYTarget.push(0);
                    droneType.push(1);
                }
                if(playerX < c.width - c.width/40 && Math.sign(playerSpeedX) == 1){
                    playerX += ml/1300 * playerSpeedX;
                } else if(Math.sign(playerSpeedX) == -1 && playerX > 0){
                    playerX += ml/1300 * playerSpeedX;
                }
                if(playerY < c.height - c.width/40 && Math.sign(playerSpeedY) == 1){
                    playerY += ml/1300 * playerSpeedY;
                } else if(Math.sign(playerSpeedY) == -1 && playerY > 0){
                    playerY += ml/1300 * playerSpeedY;
                }
                if(frameCounter >= 250 && health + (roundRegen * (regen/5000)) < maxHealth && gameState == 0){
                    health += roundRegen * (regen/5000);
                } else if (frameCounter >= 250 && gameState == 0){
                    health = maxHealth;
                }
                if(bloodCounter > bloodDuration){
                    bloodDmgMulti = 1;
                    bloodSpeedMulti = 1;
                }
                if(cloakCounter > cloakDuration && controllerMode == false){
                    cloaked = false;
                    currentCloakSpeedMulti = 1;
                }
                if(Math.abs(supplyX - playerX + ml/100) + Math.abs(supplyY - playerY + ml/100) < ml/25 && supplyDrops == true && health != maxHealth){
                    supplyX = Math.random() * c.width;
                    supplyY = Math.random() * c.height;
                    if(health + maxHealth * 0.05 >= maxHealth){
                        health = maxHealth;
                    } else{
                        health += maxHealth * 0.05;
                    }
                }
                shotDelay++;
                spawnDelay++;
                frameCounter++;
                dashCd++;
                shockwaveCd++;
                stunCounter++;
                stunCd++;
                bloodCounter++;
                refreshCounter++;
                droneCounter++;
                cloakCounter++;
                seerCounter++;
            }
            gameRenderer();
        }, 20)
        function skillRefresh(){
            dashCd = dashDelay;
            shockwaveCd = 100;
            stunCd = stunDelay;
            bloodCounter = bloodCooldown;
            cloakCounter = cloakDelay;
        }
        function resume(){
            if(smartShotToggle == true){
                autoFire = true;
            }
            gameState = 0;
            contingencyAvailable = contingencyUses;
            supplyX = Math.random() * c.width;
            supplyY = Math.random() * c.height;
            enemyDMG = enemyDMGPerWave * (wave + Math.max(0, wave - 9) + Math.max(0, wave- 19)) + 1.5;
            playerX = c.width/2 - ml/80;
            playerY = c.height/2 - ml/80;
            if(health + roundRegen * roundRegenMulti > maxHealth){
               health = maxHealth;
            } else{
                health += roundRegen * roundRegenMulti;
            }
            wave++;
            if(wave == 5){
                mutMin += -0.25;
                mutMax += 0.5;
            } else if(wave > 5 && wave <= 20){
                mutMin += -0.025;
                mutMin += 0.05;
            }
            if((4 + wave/3) * eSpeedMulti > 15){
                var enemySpeed = 15;
            } else{
                var enemySpeed = 4 + wave/3;
            }
            if (wave % 3 == 0){
                enemyDelay--;
                if(wave >= 15){
                    itemScaling += 10;
                }
            }
            if(wave == 25){
                enemyDelay += -0.4;
            }
	        if(wave > 10 && wave % 15 == 0){
                healScaling = healScaling * 2.5;
            }
            if(wave > 10 && wave % 10 == 0){
                enemyPairs++;
	        }
            enemyCap = 30 + (wave - 1) * enemyPerWave;   
        }
        function shopSellAreas(xpos, ypos, width, height){
            if(playerX + ml/40 > xpos && playerX < xpos + width && playerY + ml/40 > ypos && playerY < ypos + height && gameState == 1){
                return true;
            } else{
                return false;
            }
        }
        function specialIconRender(id, slot){
            let xoffset = 0;
            let yoffset = 0;
            if(slot % 2 == 0){
                xoffset = 8.5;
            } else{
                xoffset = 4;
            }
            switch(slot){
                case 1:
                case 2:
                    yoffset = 30;
                    break;
                case 3:
                case 4:
                    yoffset = 55;
                    break;
                case 5:
                case 6:
                    yoffset = 82;
                    break;
            }
            switch(id){
                case 6:
                    cx.fillStyle = "gray";
                    cx.shadowColor = "red";
                    cx.fillRect(c.width - c.width/xoffset - c.width/75, c.height/100 * yoffset + ml/200, c.width/75, c.height/50);
                    cx.fillRect(c.width - c.width/xoffset + ml/50, c.height/100 * yoffset + ml/200, c.width/75, c.height/50);
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    break;
                case 7:
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.fillStyle = "blueviolet";
                    cx.shadowColor = "purple";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/150, 0, Math.PI * 2, false);
                    cx.fill();
                    break;
                case 8:
                    cx.globalAlpha = 0.5;
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.globalAlpha = 1;
                    cx.shadowColor = "red";
                    cx.strokeStyle = "orange";
                    cx.lineWidth = 4;
                    cx.shadowBlur = 20;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/150, 0, Math.PI * 2, false);
                    cx.fill();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/70, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.strokeRect(c.width - c.width/xoffset - ml/150, c.height/100 * yoffset - ml/150, ml/30, ml/30);
                    cx.shadowBlur = 8;
                    cx.lineWidth = 1;
                    break;
                case 9:
                    cx.shadowColor = "orange";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.fillStyle = "yellow";
                    cx.globalAlpha = 0.35;
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/200, ml/200);
                    cx.fillRect(c.width - c.width/xoffset + ml/50 - ml/200, c.height/100 * yoffset, ml/200, ml/200);
                    cx.fillRect(c.width - c.width/xoffset + ml/50 - ml/200,  c.height/100 * yoffset + ml/50 - ml/200, ml/200, ml/200);
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + ml/50 - ml/200, ml/200, ml/200);
                    cx.globalAlpha = 1;
                    break;
                case 10:
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    cx.fillStyle = "yellow";
                    cx.shadowColor = "orange";
                    cx.fillRect(c.width - c.width/xoffset - c.width/250, c.height/100 * (yoffset + 3), ml/120, ml/120);
                    cx.fillRect(c.width - c.width/xoffset + c.width/80, c.height/100 * yoffset, ml/120, ml/120);
                    cx.fillRect(c.width - c.width/xoffset - c.width/250, c.height/100 * (yoffset - 1), ml/120, ml/120);
                    break;
                case 11:
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    cx.fillStyle = "grey";
                    cx.shadowColor = primeColor;
                    cx.fillRect(c.width - c.width/xoffset + c.width/240, c.height/100 * (yoffset + 1), c.width/120, c.height/20);
                    break;
                case 12:
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "white";
                    cx.strokeStyle = "cyan";
                    cx.lineWidth = 3;
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 2), ml/50, ml/50);
                    cx.strokeRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 2), ml/50, ml/50);
                    cx.lineWidth = 1;
                    break;
                case 13:
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "black";
                    cx.fillRect(c.width - c.width/xoffset + ml/100, c.height/100 * (yoffset + 1), c.width/150, c.width/30);
                    break;
                case 14:
                    cx.shadowColor = "orange";
                    cx.fillStyle = "black";
                    cx.strokeStyle = "orange";
                    cx.lineWidth = 2;
                    cx.fillRect(c.width - c.width/xoffset + c.width/200, c.height/100 * (yoffset + 2) + ml/200, ml/100, ml/100);
                    cx.strokeRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 2), ml/50, ml/50);
                    cx.lineWidth = 1;
                    break;
                case 15:
                    cx.fillStyle = "gray";
                    cx.shadowColor = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/75, c.height/18.75);
                    cx.fillStyle = "orange";
                    cx.shadowColor = "red";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/18.75, c.width/75, c.height/75);
                    break;
                case 16:
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.lineWidth = 3;
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.strokeStyle = "blueviolet";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/65, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 17:
                    cx.shadowColor = "gold";
                    cx.shadowBlur = 20;
                    cx.fillStyle = "orange";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.shadowBlur = 8;
                    break;
                case 18:
                    cx.fillStyle = "gray";
                    cx.shadowColor = "cyan";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/75, c.height/15);
                    cx.fillStyle = "red";
                    cx.shadowColor = "orange";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/75, c.height/62.5);
                    break;
                case 19:
                    cx.lineWidth = 3;
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    cx.strokeStyle = "red";
                    cx.shadowColor = "orange";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100 + c.height/100, ml/50, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 20:
                    cx.lineWidth = 3;
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    cx.strokeStyle = "green";
                    cx.shadowColor = "green";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100 + c.height/100, ml/40, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100 + c.height/100, ml/60, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 21:
                    cx.shadowColor = "red";
                    cx.strokeStyle = "red";
                    cx.beginPath();
                    cx.lineWidth = 4;
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/80, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/160, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 22:
                    cx.shadowColor = "cyan";
                    cx.strokeStyle = "white";
                    cx.lineWidth = 1;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/80, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/160, 0, Math.PI * 2, false);
                    cx.stroke();
                    break;   
                case 23:
                    cx.shadowColor = "red";
                    cx.strokeStyle = "orange";
                    cx.lineWidth = 2;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/80, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/160, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;   
                case 24:
                    cx.shadowColor = "darkgreen";
                    cx.strokeStyle = "green";
                    cx.lineWidth = 3;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/80, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/160, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 25:
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.shadowColor = "green";
                    cx.fillStyle = "green";
                    cx.fillRect(c.width - c.width/xoffset + ml/200 + ml/400, c.height/100 * yoffset - ml/100, ml/200, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + ml/200 + ml/400, c.height/100 * yoffset + ml/50, ml/200, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - ml/100, c.height/100 * yoffset + ml/200 + ml/400, ml/100, ml/200);
                    cx.fillRect(c.width - c.width/xoffset + ml/50, c.height/100 * yoffset + ml/200 + ml/400, ml/100, ml/200);
                    break;
                case 26:
                    cx.shadowColor = "green";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.fillStyle = "red";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/200, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + ml/50 - ml/200, c.height/100 * yoffset, ml/200, ml/100);
                    break;
                case 27:
                    cx.shadowColor = "black";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    break;
                case 28:
                    cx.shadowColor = "black";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.strokeStyle = "darkorchid";
                    cx.shadowColor = "black";
                    cx.lineWidth = 4;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/60, 0, Math.PI, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 29:
                    cx.shadowColor = "green";
                    cx.fillStyle = "black";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.strokeStyle = "darkorchid";
                    cx.shadowColor = "black";
                    cx.fillStyle = "darkorchid";
                    cx.fillRect(c.width - c.width/xoffset + ml/100 - ml/400, c.height/100 * (yoffset + 0.5), ml/200, ml/200)
                    cx.lineWidth = 4;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/60, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 30:
                    cx.shadowColor = "green";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset - c.width/135, c.height/100 * (yoffset - 2), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + c.width/65, c.height/100 * (yoffset), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + c.width/120, c.height/100 * (yoffset + 4), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/120, c.height/100 * (yoffset + 4), ml/100, ml/100);
                    break;
                case 31:
                    cx.shadowColor = "green";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset + ml/100 - ml/300, c.height/100 * yoffset + c.height/100, ml/150, ml/75);
                    break;
                case 32:
                    cx.lineWidth = 3;
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.shadowColor = "white";
                    cx.strokeStyle = "gray";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/50, Math.PI/4 * 6, Math.PI/4 * 8);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/50, Math.PI/2, Math.PI);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 33:
                    cx.lineWidth = 3;
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.shadowColor = "white";
                    cx.strokeStyle = "gray";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/50, 0, Math.PI * 2);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 34:
                    cx.lineWidth = 3;
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.shadowColor = "black";
                    cx.strokeStyle = "red";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/50, 0, Math.PI * 2);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 35:
                    cx.shadowColor = "red";
                    cx.fillStyle = "white";
                    cx.strokeStyle = "red";
                    cx.lineWidth = 3;
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 2), ml/50, ml/50);
                    cx.strokeRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 2), ml/50, ml/50);
                    cx.lineWidth = 1;
                    break;
                case 36:
                    cx.shadowColor = "black";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    cx.fillStyle = "grey";
                    cx.shadowColor = "red";
                    cx.fillRect(c.width - c.width/xoffset + c.width/240, c.height/100 * (yoffset + 1), c.width/120, c.height/20);
                    break;
                case 37:
                    cx.shadowColor = "gray";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    cx.shadowColor = "orange";
                    cx.strokeStyle = "red";
                    cx.lineWidth = 2;
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100 + c.height/100, ml/80, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100 + c.height/100, ml/120, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 38:
                    cx.shadowColor = "red";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset + ml/100 - ml/300, c.height/100 * yoffset + c.height/100, ml/150, ml/75);
                    break;
                case 39:
                    cx.fillStyle = "red";
                    cx.shadowColor = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/75, c.height/18.75);
                    break;
                case 40:
                    cx.shadowColor = "orange";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    break;
                case 41:
                    cx.shadowColor = "red";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    cx.fillStyle = "black";
                    cx.shadowColor = "red";
                    cx.fillRect(c.width - c.width/xoffset - c.width/250, c.height/100 * (yoffset + 3), ml/120, ml/120);
                    cx.fillRect(c.width - c.width/xoffset + c.width/80, c.height/100 * yoffset, ml/120, ml/120);
                    cx.fillRect(c.width - c.width/xoffset - c.width/250, c.height/100 * (yoffset - 1), ml/120, ml/120);
                    break;
                case 42:
                    cx.shadowColor = "white";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    break;
                case 43:
                    cx.shadowColor = "black";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    break;
                case 44:
                    cx.shadowColor = "white";
                    cx.fillStyle = "gold";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    break;
                case 45:
                    cx.lineWidth = 2;
                    cx.shadowColor = "cyan";
                    cx.strokeStyle = "darkorchid";
                    cx.strokeRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/120, c.height/100 * yoffset + ml/100 + c.height/100, ml/120, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.fillStyle = "white";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/120, c.height/100 * yoffset + ml/100 + c.height/100, ml/200, 0, Math.PI * 2, false);
                    cx.fill();
                    cx.lineWidth = 1;
                    break;
                case 46:
                    cx.fillStyle = "blue";
                    cx.shadowColor = "blue";
                    cx.fillRect(c.width - c.width/xoffset - c.width/75, c.height/100 * yoffset + ml/200, c.width/75, c.height/50);
                    cx.fillRect(c.width - c.width/xoffset + ml/50, c.height/100 * yoffset + ml/200, c.width/75, c.height/50);
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    break;
                case 47:
                    cx.lineWidth = 3;
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.shadowColor = "cyan";
                    cx.strokeStyle = "white";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/50, Math.PI/4 * 6, Math.PI/4 * 8);
                    cx.stroke();
                    cx.shadowColor = "red";
                    cx.strokeStyle = "gray";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100, ml/50, Math.PI/2, Math.PI);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
                case 48:
                    cx.globalAlpha = 0.5;
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.globalAlpha = 1;
                    break;
                case 49:
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "blue";
                    cx.fillRect(c.width - c.width/xoffset + ml/100, c.height/100 * (yoffset + 1), c.width/150, c.width/30);
                    break;
                case 50:
                    cx.shadowColor = "cyan";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, ml/50, ml/50);
                    cx.fillStyle = "yellow";
                    cx.fillRect(c.width - c.width/xoffset + ml/100 - ml/300, c.height/100 * yoffset, ml/150, ml/50);
                    break;
                case 51:
                    cx.shadowColor = "white";
                    cx.fillStyle = "hotpink";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset, c.width/60, c.height/15);
                    break;
                case 52:
                    cx.shadowColor = "orange";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset - c.width/135, c.height/100 * (yoffset - 2), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + c.width/65, c.height/100 * (yoffset), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + c.width/120, c.height/100 * (yoffset + 4), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/120, c.height/100 * (yoffset + 4), ml/100, ml/100);
                    break;
                case 57:
                    cx.shadowColor = "orange";
                    cx.fillStyle = "gray";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * yoffset + c.height/100, ml/50, ml/50);
                    cx.fillStyle = "yellow";
                    cx.fillRect(c.width - c.width/xoffset + ml/100 - ml/300, c.height/100 * yoffset + c.height/100, ml/150, ml/75);
                    break;
                case 53:
                    cx.shadowColor = "yellow";
                    cx.fillStyle = "orange";
                    cx.fillRect(c.width - c.width/xoffset + c.width/100, c.height/100 * (yoffset + 1.5), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/100, c.height/100 * (yoffset + 1.5), ml/100, ml/100);
                    break;
                case 54:
                    cx.shadowColor = "yellow";
                    cx.fillStyle = "orange";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset - 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 3), ml/100, ml/100);
                    break;
                case 55:
                    cx.shadowColor = "yellow";
                    cx.fillStyle = "orange";
                    cx.fillRect(c.width - c.width/xoffset + c.width/100, c.height/100 * (yoffset - 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + c.width/100, c.height/100 * (yoffset + 3), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/100, c.height/100 * (yoffset - 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/100, c.height/100 * (yoffset + 3), ml/100, ml/100);
                    break;
                case 56:
                    cx.shadowColor = "black";
                    cx.fillStyle = "purple";
                    cx.fillRect(c.width - c.width/xoffset + c.width/100, c.height/100 * (yoffset - 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset + c.width/100, c.height/100 * (yoffset + 3), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/100, c.height/100 * (yoffset - 1), ml/100, ml/100);
                    cx.fillRect(c.width - c.width/xoffset - c.width/100, c.height/100 * (yoffset + 3), ml/100, ml/100);
                    cx.fillStyle = "white";
                    cx.shadowColor = "orange";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 1), ml/100, ml/100);
                    break;
                case 58:
                    cx.shadowColor = "orange";
                    cx.fillStyle = "white";
                    cx.fillRect(c.width - c.width/xoffset, c.height/100 * (yoffset + 1), ml/50, ml/50);
                    cx.strokeStyle = "yellow";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * (yoffset - 3) + ml/100, ml/150, 0, Math.PI * 2);
                    cx.stroke();
                    break;
                case 60:
                    cx.shadowColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                    cx.fillStyle = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                    cx.fillRect(c.width - c.width/xoffset + ml/100, c.height/100 * (yoffset + 1), c.width/150, c.width/30);  
                    break;
                case 59:
                    cx.lineWidth = 10;
                    cx.strokeStyle = "lime";
                    cx.shadowColor = "green";
                    cx.beginPath();
                    cx.arc(c.width - c.width/xoffset + ml/100, c.height/100 * yoffset + ml/100 + c.height/100, ml/50, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                    break;
            }
        }
        function gameRenderer(){
            if(chaosMode == false){
                cx.clearRect(0, 0, c.width, c.height);
            }
            if(gameState != 1){
                if(gameState != 2){
                    cx.globalAlpha = 0.5;
                }
                cx.strokeStyle = "black";
                if(wave < 5){
                    cx.shadowColor = "#032966";  
                } else if (wave < 10){
                    cx.shadowColor = "green";
                } else if(wave < 15){
                    cx.shadowColor = "firebrick";
                } else if(wave < 20){
                    cx.shadowColor = "orange";
                } else if(wave < 25){
                    cx.shadowColor = "gray";
                } else if(wave < 30){
                    cx.shadowColor = "hotpink";
                } else{
                    cx.shadowColor = "#3d3d3d";
                }
                for(let t = 0; t < 40; t++){
                    cx.strokeRect(c.width/40 * t, 0, 1, c.height);
                    if(t % 2 == 0){
                        cx.strokeRect(0, c.height/40 * t, c.width, 1);
                    }
                }
               cx.globalAlpha = 1;
            }
            if(gameState == 0 || gameState == 3){
                for(let i = 0; i < droneX.length; i++){
                    if(droneType[i] == 0){
                        cx.fillStyle = primeColor;
                        cx.shadowColor = "white";
                        cx.fillRect(droneX[i], droneY[i], ml/50, ml/50);
                    } else{
                        cx.strokeStyle = "black";
                        cx.shadowColor = "hotpink";
                        cx.lineWidth = 3;
                        cx.strokeRect(droneX[i], droneY[i], ml/50, ml/50);
                        cx.lineWidth = 1;
                    }
                }
            }
            if(supplyDrops == true && gameState == 0){
                cx.lineWidth = 3;
                cx.strokeStyle = "lime";
                cx.shadowColor = "green";
                cx.beginPath();
                cx.arc(supplyX, supplyY, ml/35, 0, Math.PI * 2);
                cx.stroke();
                cx.lineWidth = 1;
            }
            for(let i = 0; i < enemyX.length; i++){
                cx.fillStyle = "grey";
                cx.shadowColor = "red";
                cx.lineWidth = 3;
                cx.shadowBlur = 20;
                cx.fillRect(enemyX[i], enemyY[i], ml/40, ml/40);
            }
            cx.font = ml/75 + "px Arial";
            if(shopSellAreas(c.width/3.2 + c.width/8, c.height/100 * 70, c.width/8, c.height/3.8) == true){
                inspecting = 5;
                slotinspecting = 0;
            } else if(shopSellAreas(c.width/3.2, 0, c.width/8, c.height/3 * 2) == true && shopPurchased[0] == false){
                inspecting = 1;
                slotinspecting = 0;
            } else if (shopSellAreas(c.width/3.2 + c.width/8, 0, c.width/8, c.height/3 * 2) == true && shopPurchased[1] == false){
                inspecting = 2;
                slotinspecting = 0;
            } else if (shopSellAreas(c.width/3.2 + c.width/4, 0, c.width/8, c.height/3 * 2) == true && shopPurchased[2] == false){
                inspecting = 3;
                slotinspecting = 0;
            } else if(shopSellAreas(c.width - c.width/6.4, c.height/4, c.width/6.4, c.height/4) == true && slot2.length != 0 && uniqueCap != 0){
                slotinspecting = 2;
                inspecting = slot2[0];
            } else if(shopSellAreas(c.width - c.width/3.2, c.height/2, c.width/6.4, c.height/4) == true && slot3.length != 0 && uniqueCap != 0){
                slotinspecting = 3;
                inspecting = slot3[0];
            } else if (shopSellAreas(c.width - c.width/6.4, c.height/2, c.width/6.4, c.height/4) == true && slot4.length != 0 && uniqueCap != 0){
                slotinspecting = 4;
                inspecting = slot4[0];
            } else if(shopSellAreas(c.width - c.width/3.2, c.height/4, c.width/6.4, c.height/4) == true && slot1.length != 0 && uniqueCap != 0){
                slotinspecting = 1;
                inspecting = slot1[0];
            } else if (shopSellAreas(c.width - c.width/3.2, 0, c.width/6.4, c.height/4) == true && healthBought == false){
                inspecting = 4;
                slotinspecting = 0;
            } else if (shopSellAreas(c.width - c.width/6.4, c.height/4 * 3, c.width/6.4, c.height/4) == true && slot6.length != 0 && uniqueCap != 0){
                slotinspecting = 6;
                inspecting = slot6[0];
            } else if (shopSellAreas(c.width - c.width/3.2, c.height/4 * 3, c.width/6.4, c.height/4) == true && slot5.length != 0 && uniqueCap != 0){
                slotinspecting = 5;
                inspecting = slot5[0];
            } else{
                slotinspecting = 0;
                inspecting = 0;
            }
            switch(inspecting){
                case 1:
                case 2:
                case 3:
                    cx.strokeStyle = "lime";
                    cx.shadowColor = "green";
                    cx.strokeText("+" + shopHP[inspecting - 1] + " Max Health", c.width/7, c.height/100 * 25);
                    cx.strokeText("+" + shopDMG[inspecting - 1] + " Damage", c.width/7, c.height/100 * 30);
                    cx.strokeText("+" + (shopSpeed[inspecting - 1] * 2) + " Move Speed", c.width/7, c.height/100 * 35);
                    cx.strokeText("+" + Math.round(shopAttackSpeed[inspecting - 1] * 10) + " Attack Speed", c.width/7, c.height/100 * 40);
                    cx.strokeText("+" + shopRegen[inspecting - 1] + " Regen/Round", c.width/7, c.height/100 * 45);
                    if(cyCoin < shopPrices[inspecting - 1]){
                        cx.strokeStyle = "hotpink";
                        cx.shadowColor = "red";
                        cx.strokeText("Insufficent Funds", c.width/7, c.height/100 * 80); 
                    }
                    cx.strokeStyle = "gold";
                    cx.shadowColor = "goldenrod";
                    cx.strokeText("Price: " + shopPrices[inspecting - 1] + " CyCoins", c.width/7, c.height/100 * 90);                    
                    cx.strokeText("Press Space to Buy", c.width/7, c.height/100 * 95);
                    break;
                case 4:
                    descriptionHandler("Repair Nanobots", "Loan the services of medical nano bots to heal " + (healBotAmount * 100) + "% of your max hp. Can buy once per wave.", 125 + Math.round(wave * healScaling), "pink", "red");
                    if(health == maxHealth){
                        cx.strokeStyle = "pink";
                        cx.shadowColor = "red";
                        cx.strokeText("Health Capacity Reached!", c.width/7, c.height/100 * 75); 
                    }
                    break;
                case 5:
                    cx.lineWidth = 0.5;
                    cx.strokeStyle = "hotpink";
                    cx.shadowColor = "hotpink";
                    cx.strokeText("Press Space to begin", c.width/7, c.height/100 * 30);
                    cx.strokeText("the next wave.", c.width/7, c.height/100 * 35);
                    break;
                case 6:
                    descriptionHandler("Dual Cannon", "Every time you fire, a second bullet will fly opposite to where you aim.", multiShotPrice, "red", "orange");
                    break;
                case 7:
                    descriptionHandler("Chaos Core", "Every time you fire, another bullet will fire in a random direction.", multiShot2Price, "red", "orange");
                    break;
                case 8:
                    descriptionHandler("Zenith Firestorm", "Every time you fire, one randomly directed bullet with shooot and two bullets will fire based upon where you aim. ", multiShot3Price, "red", "orange");
                    break;
                case 9:
                    descriptionHandler("Summit Star", "The power of stars is unrivaled by anything known to man...", multiShot4Price, "darkorchid", "black");
                    break;
                case 10:
                    descriptionHandler("Gambler's Gun", "Enables Smartshot. Press E to toggle Smartshot. It will automatically aim at a random enemy until it dies.", gambleFirePrice, "white", "cyan");
                    break;
                case 11:
                    descriptionHandler("Artificial Bullets", "Enhances Smartshot. Smartshot now automatically aims at the closest enemy.", smartFirePrice, "white", "cyan");
                    break;
                case 12:
                    descriptionHandler("Blink Drive", "Enables Blink. Press space to blink. It will teleport you forward a short distance and grant you brief invulnerability.", dashPrice, "green", "darkgreen");
                    break;
                case 13:
                    descriptionHandler("Plasmoid Trail", "Enhances Blink. Blinking leaves a damaging area behind. Also decreases the cooldown.", dash2Price, "white", "cyan");
                    break;
                case 14:
                    descriptionHandler("Burning Destruction", "Enhances Blink. The damage effect lasts twice as long and it deals 33% more damage.", dash3Price, "white", "cyan");
                    break;
                case 15:
                    descriptionHandler("Bullet Thrusters", "Doubles the speed at which your bullets travel.", statSpecialPrice, "gray", "gray");
                    break;
                case 16:
                    descriptionHandler("Hyper Shields", "Makes your damage and dash iframes last 1.5x longer.", statSpecial2Price, "green", "darkgreen");
                    break;
                case 17:
                    descriptionHandler("Generous Donation", "All standard stat items in wave shops after this purchase will have better stats.", statSpecial3Price, "orange", "yellow");
                    break;
                case 18:
                    descriptionHandler("Bullet Punching", "Enables Knockback. If you hit an enemy and do not kill them, they will be knocked back a short distance. Scales with bullet speed.", knockbackPrice, "red", "orange");
                    break;
                case 19:
                    descriptionHandler("Engine Overload", "Enables Shockwave. Press F to fire a shockwave, knocking back all enemies in an area around you.", shockwavePrice, "green", "darkgreen");   
                    break;
                case 20:
                    descriptionHandler("Pulse Wave", "Enhances Shockwave. Shockwave now knocks back all enemies, not just enemies in range.", shockwave2Price, "green", "darkgreen");
                    break;
                case 21:
                    descriptionHandler("Arsenal Pact", "Pledge your alliance to the faction Arsenal. Conquer the horde with sheer force.", 0, "red", "orange");
                    break;
                case 22:
                    descriptionHandler("Artificer Pact", "Pledge your alliance to the faction Artificer. Strike when the moment is right, be precise in your actions.", 0, "white", "cyan");
                    break;
                case 23:
                    descriptionHandler("Artisan Pact", "Pledge your alliance to the faction Artisan. The strength of your allies is the strength of your own.", 0, "orange", "yellow");
                    break;
                case 24:
                    descriptionHandler("Armor Pact", "Pledge your alliance to the faction Armor. You cannot succeed unless you survive.", 0, "green", "darkgreen");
                    break;
                case 25:
                    descriptionHandler("Retaliation Charge", "Enables Retaliation. Upon taking damage, deal damage to enemies around you based upon your bullet damage.", retaliationPrice, "green", "darkgreen");
                    break;
                case 26:
                    descriptionHandler("Destroyer Armor", "Enhances Retaliation. Deals greater damage in a larger area.", retaliation2Price, "green", "darkgreen");
                    break;
                case 27:
                    descriptionHandler("Goliath Armor", "Receive half the damage dealt to you.", goliathPrice, "green", "darkgreen");
                    break;
                case 28:
                    descriptionHandler("Totality Shield", "Receive 1/4 the damage dealt to you, and expand the retaliation area.", totalityPrice, "green", "darkgreen");
                    break;
                case 29:
                    descriptionHandler("Sentinal Aura", "An ancient being from beyond, leaving nothing but death in it's wake...", sentinalAuraPrice, "darkorchid", "black");
                    break;
                case 30:
                    descriptionHandler("Personal Nanobots", "Enables Regen. After not taking damage for 5 seconds, regen 4% of your regen stat per second.", regenPrice, "white", "cyan");
                    break;
                case 31:
                    descriptionHandler("Doctorate Promotion", "Enhances Regen. Regenerate an additional 8% of your regen stat per second out of combat.", regen2Price, "green", "darkgreen");
                    break;
                case 32:
                    descriptionHandler("EMP", "Enables EMP. Press Z to stun all enemies for 2 seconds.", stunPrice, "red", "orange");
                    break;
                case 33:
                    descriptionHandler("Concentrated Wave", "Enhances EMP. EMP now stuns for 4 seconds.", stun2Price, "green", "darkgreen");
                    break;
                case 34:
                    descriptionHandler("Opressive Virus", "Enhances EMP. EMP now only stuns for 1 second, but applies a damage-over-time effect to all enemies based upon your current bullet damage.", stun2AltPrice, "red", "orange");
                    break;
                case 35:
                    descriptionHandler("Scrappy Bullets", "Enables Blood Boost. Press X to sacrifice hp equal to 15% of your max hp to double all outgoing damage for 5 seconds.", bloodSacPrice, "red", "orange");
                    break;
                case 36:
                    descriptionHandler("Overclocked Weapons", "Enhances Blood Boost. Blood boost now also doubles your attack speed for the duration. (Note: if at 120 attack speed, does nothing).", bloodSac2Price, "red", "orange");
                    break;
                case 37:
                    descriptionHandler("Cautious Ritual", "Reduce the cost of Blood Boost down to 10% and increase it's duration by 2 seconds.", bloodSac3Price, "red", "orange");
                    break;
                case 38:
                    descriptionHandler("Scrap Repairs", "Increases end of round regen by an additive 100%.", regenBoostPrice, "red", "orange");
                    break;
                case 39:
                    descriptionHandler("Hungering Bullets", "Restore 0.5 hp upon killing an enemy with a bullet. Additional purchases adds 0.5 more hp per kill.", leechPrice, "red", "orange");
                    break;
                case 40:
                    descriptionHandler("Goods Appraisal", "Gain 1.25X more cycoins.", appraisalPrice, "orange", "yellow");
                    break;
                case 41:
                    descriptionHandler("Splintering Bullets", "Increase all damage by 25%.", damageBoostPrice, "red", "orange");
                    break;
                case 42:
                    descriptionHandler("Freeze Shot", "Enables Freeze Shot. Every 3rd shot, fire a freeze bullets. Enemies struck with a freeze bullet that do not die will have their speed reduced by 50%.", freezeShotPrice, "white", "cyan");
                    break;
                case 43:
                    descriptionHandler("Hard Shot", "Enables Hard Bullets. Every 5th shot, fire a hard bullet. Enemies struck with a hard bullet always die, regardless of their health.", hardBulletPrice, "white", "cyan");
                    break;
                case 44:
                    descriptionHandler("Sharp Shot", "Enables Sharp Bullets. Every 20th shot, fire a sharp bullet. Enemies struck with a sharp bullet always die, and the sharp bullet will pierce through them.", sharpBulletPrice, "white", "cyan");
                    break;
                case 45:
                    descriptionHandler("Ultima Shot", "Every 200th shot, leave nothing standing.", ultimaPrice, "darkorchid", "black");
                    break;
                case 46:
                    descriptionHandler("Advanced Coolant", "Increases the attack speed cap to 240. Attack speeed above 120 does nothing, but upon reaching 240 attack speed, attack twice per shot.", coolantPrice, "white", "cyan");
                    break;
                case 47:
                    descriptionHandler("Directed Overheat", "Enhances Shockwave. Shockwave now deals damage to all enemies it hits, equal to 75% of your bullet damage.", shockwave2AltPrice, "white", "cyan");
                    break;
                case 48:
                    descriptionHandler("Cloaking Device", "Enables Cloaking. Press C to cloak, becoming invisibile and intangible for 4 seconds. However, you cannot shoot while cloaked.", cloakPrice, "white", "cyan");
                    break;
                case 49:
                    descriptionHandler("Coolant Flood", "Enables Refresh. Press R to refresh, instantly taking all of you active abilities off cooldown. Cooldown: 20 seconds.", refreshPrice, "white", "cyan");
                    break;  
                case 50:
                    descriptionHandler("Power Divergence", "Enhances Cloaking. While cloaked, you can now attack at half the attack speed you normally would.", cloak2Price, "white", "cyan");
                    break;
                case 51:
                    descriptionHandler("Extractor Shot", "Enables Extract Bullets. Every 35th shot, fire an extractor bullet. If the extractor bullet hits an enemy, heal 50 hp.", extractPrice, "white", "cyan");
                    break;
                case 52:
                    descriptionHandler("Local Services", "Reduces the prices of nanobots by 50%, and increases the amount healed by 15%.", servicesPrice, "orange", "yellow");
                    break;
                case 57:
                    descriptionHandler("Enhanced Model", "Increases the attack speed multiplier for drones from " + Math.round(droneSpeed * 10)/10 + "x to " + Math.round((droneSpeed + 0.1) * 10)/10 + "x your attack speed.", droneBuffPrice, "orange", "yellow");
                    break;
                case 53:
                    descriptionHandler("Hired Help", "Gain two static turrets on each side of the screen. They will fire at a reduced attack speed at the enemy closest to themself.", sideDronePrice, "orange", "yellow");
                    break;
                case 54:
                    descriptionHandler("Expanded Forces", "Gain two more static turrets, at the top and bottom of the area.", topDronePrice, "orange", "yellow");
                    break;
                case 55:
                    descriptionHandler("Automated Expansion", "Gain four more static turrets, one at each corner.", cornerDronePrice, "orange", "yellow");
                    break;
                case 56:
                    descriptionHandler("Drone Overseer", "You need not face the horde alone.", droneSeerPrice, "darkorchid", "black");
                    break;
                case 58:
                    descriptionHandler("Shadow Controller", "Replaces Cloak with Controller Mode. Press C to toggle Controller Mode. While in controller mode, drones fire at 2x attack speed.", controllerPrice, "orange", "yellow");
                    break;
                case 60:
                    descriptionHandler("Contingency Call", "Press T to activate the contingency plan. Can be used once per wave.", contingencyPrice, "orange", "yellow");
                    break;
                case 59:
                    descriptionHandler("Supply Drops", "During combat, heal zones will spawn. Touching the heal zone will heal you for " + (supplyHeal * 100 + 3) + "% your max hp and than move the zone.", supplyPrice, "orange", "yellow");
                    break;
                case 61:
                    descriptionHandler("The Forbidden Power", "Everything has a price - the price of this is just not apparent until it is used.", 0, "darkorchid", "black");
                    break;
            }
            if(gameState == 1){
                cx.beginPath();
                cx.fillStyle = "black";
                cx.shadowColor = "white";
                cx.globalAlpha = 0.9;
                cx.arc(c.width/2, c.height/6 + c.height/15, ml/17.5, 0, Math.PI * 2);
                cx.fill();
                cx.globalAlpha = 1;
                cx.globalAlpha = 0.1;
                cx.fillStyle = "gray";
                cx.shadowColor = "white";
                cx.fillRect(c.width - c.width/3.2, 0, c.width/3.2, c.height);
                cx.fillRect(0, 0, c.width/3.2, c.height);
                cx.globalAlpha = 1;
                if(inspecting != 0){
                    cx.lineWidth = 4;
                    cx.strokeStyle = "black";
                    cx.shadowColor = "darkblue";
                    cx.strokeRect(4, 4, c.width/3.2 - 12, c.height - 10);
                    cx.lineWidth = 1;
                }
                cx.lineWidth = 8;
                cx.shadowColor = "blueviolet";
                cx.strokeStyle = "black";
                cx.beginPath();
                cx.arc(c.width/2, c.height/1.2, ml/15, 0, Math.PI * 2, false);
                cx.stroke();
                cx.lineWidth = 2.6;
                cx.textAlign = "center";
                cx.font = ml/80 + "px Arial";
                cx.strokeText("R E T U R N.", c.width/2, c.height/1.2);
                cx.shadowColor = "gold";
                cx.shadowBlur = 20;
                cx.fillStyle = "orange";
                cx.fillRect(c.width/2 - ml/30, c.height/6, ml/15, ml/15);
                cx.shadowColor = "gray";
                cx.shadowBlur = 8;
                cx.fillStyle = "black";
                cx.fillRect(c.width/2 - ml/50, c.height/2.8, ml/25, ml/25);
                cx.fillRect(c.width/2.5 - ml/50, c.height/2.8, ml/25, ml/25);
                cx.fillRect(c.width/1.6667 - ml/50, c.height/2.8, ml/25, ml/25);
                if(shopPurchased[1] == false){
                    cx.shadowColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
		            cx.fillStyle = shopColor2;
                    cx.beginPath();
                    cx.arc(c.width/2, c.height/2.8 + ml/50, ml/75, 0, Math.PI * 2, false);
                    cx.fill();
                }
                if(shopPurchased[0] == false){
                    cx.shadowColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
		            cx.fillStyle = shopColor3;
                    cx.beginPath();
                    cx.arc(c.width/2.5, c.height/2.8 + ml/50, ml/75, 0, Math.PI * 2, false);
                    cx.fill();
                }
                if(shopPurchased[2] == false){
                    cx.shadowColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
		            cx.fillStyle = shopColor1;
                    cx.beginPath();
                    cx.arc(c.width/1.6667, c.height/2.8 + ml/50, ml/75, 0, Math.PI * 2, false);
                    cx.fill();
                }
                if(healthBought == false){
                    cx.shadowColor = "hotpink";
                    cx.fillStyle = "grey";
                    cx.fillRect(c.width - c.width/4, c.height/100 * 10, ml/100, ml/100);
                    cx.fillRect(c.width - c.width/4.5, c.height/100 * 12, ml/100, ml/100);
                    cx.fillRect(c.width - c.width/4.2, c.height/100 * 13, ml/100, ml/100);
                    cx.fillRect(c.width - c.width/4.3, c.height/100 * 16, ml/100, ml/100);
                    cx.fillRect(c.width - c.width/4.05, c.height/100 * 16, ml/100, ml/100);
                }
                if(uniqueCap != 0){
                   specialIconRender(slot1[0], 1);
                   specialIconRender(slot2[0], 2);
                   specialIconRender(slot3[0], 3);
                   specialIconRender(slot4[0], 4);
                   specialIconRender(slot5[0], 5);
                   specialIconRender(slot6[0], 6);
                }
                cx.shadowBlur = 8;
                cx.shadowColor = "cyan";
                cx.lineWidth = 1.5;
                cx.strokeStyle = "white";
                cx.font = c.height/50 + "px Arial";
                cx.strokeText("Max HP: " + maxHealth, c.width - c.width/14, c.height/100 * 4);
                cx.strokeText("Damage: " + damage + " (" + damageMulti + "X)", c.width - c.width/14, c.height/100 * 8);
                cx.strokeText("Move Speed: " + (playerSpeed * 2), c.width - c.width/14, c.height/100 * 12);
                cx.strokeText("Attack Speed: " + (120 - Math.round(attackSpeed*10)), c.width - c.width/14, c.height/100 * 16);
                cx.strokeText("Regen/Round: " + roundRegen + " (" + roundRegenMulti + "X)", c.width - c.width/14, c.height/100 * 20);
                cx.strokeText("Uniques Left: " + uniqueCap, c.width - c.width/14, c.height/100 * 24);
            }
            for(let i = 0; i < laserY.length; i++){
                cx.shadowColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                cx.fillStyle = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                cx.fillRect(0, laserY[i], c.width, c.height/10);
            }
            for(let i = 0; i < bullXPos.length; i++){
                switch(bulletProperties[i]){
                    case 0:
                        cx.shadowColor = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                        cx.fillStyle = "rgb(" + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ", " + Math.floor(Math.random() * 256) + ")";
                        break;
                    case 1:
                        cx.fillStyle = "white";
                        cx.shadowColor = "white";
                        break;
                    case 2:
                        cx.fillStyle = "gray";
                        cx.shadowColor = "black";
                        break;
                    case 3:
                        cx.fillStyle = "goldenrod";
                        cx.shadowColor = "white";
                        break;
                    case 4:
                        cx.fillStyle = "darkorchid";
                        cx.shadowColor = "black";
                        break;
                    case 5:
                        cx.fillStyle = "hotpink";
                        cx.shadowColor = "white";
                        break;
                }
                cx.shadowBlur = 8;
                cx.fillRect(bullXPos[i] - ml/200, bullYPos[i] - ml/200, ml/100, ml/100);
                if(bullXPos[i] > c.width || bullXPos[i] < 0 || bullYPos[i] > c.height || bullYPos[i] < 0){
                    bullXPos.splice(i, 1);
                    bullYPos.splice(i, 1);
                    bullXMomentum.splice(i, 1);
                    bullYMomentum.splice(i, 1);
                    bulletProperties.splice(i, 1);
                }
            }
            if(gameState != 2){
                cx.lineWidth = 1;
                if(retaliationStage > 4){
                    cx.fillStyle = "black";
                } else{
                    cx.fillStyle = "white";
                }
                if(frameCounter < iFrames && frameCounter % 6 == 0 || cloaked == true){
                    cx.globalAlpha = 0.1;
                    if(cloaked == true && controllerMode == true){
                        cx.globalAlpha = 1;
                        cx.lineWidth = 3;
                        cx.shadowColor = "orange";
                        cx.strokeStyle = "yellow";
                        cx.beginPath();
                        cx.arc(playerX + ml/80, playerY - ml/80, ml/120, 0, Math.PI * 2, false);
                        cx.stroke();
                        cx.lineWidth = 1;
                    }
                }
                cx.shadowColor = primeColor;  
                cx.shadowBlur = 20;
                cx.fillRect(playerX, playerY, ml/40, ml/40);
                cx.shadowBlur = 8;
                if(frameCounter <= 5 && retaliationStage != 0){
                    if(retaliationStage != 5){
                        cx.strokeStyle = "darkgreen";
                        cx.shadowColor = "darkgreen";
                    } else{
                        cx.strokeStyle = "darkorchid";
                        cx.shadowColor = "black";
                    }
                    cx.lineWidth = 3;
                    cx.beginPath();
                    cx.arc(playerX + ml/80, playerY + ml/80, ml/retaliationSize/2, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                }
                if(droneSeer == true){
                    cx.fillStyle = "purple";
                    cx.shadowColor = "black";
                    cx.fillRect(playerX, playerY + ml/40 - ml/160, ml/40, ml/160);
                }
                if(summmitStar == true){
                    cx.fillStyle = "yellow";
                    cx.globalAlpha = 0.35;
                    cx.fillRect(playerX, playerY, ml/150, ml/150);
                    cx.fillRect(playerX + ml/40 - ml/150, playerY, ml/150, ml/150);
                    cx.fillRect(playerX + ml/40 - ml/150, playerY + ml/40 - ml/150, ml/150, ml/150);
                    cx.fillRect(playerX, playerY + ml/40 - ml/150, ml/150, ml/150);
                    cx.globalAlpha = 1;
                }
                if(cloakCounter > cloakDelay && cloak == true || controllerMode == true){
                    if(controllerMode == true){
                        cx.shadowColor = "orange";
                        cx.fillStyle = "yellow";
                    } else{
                        cx.shadowColor = "cyan";
                        cx.fillStyle = "blue";
                    }
                    cx.fillRect(playerX + ml/80 - ml/300, playerY, ml/150, ml/150);
                }
                if(refreshCounter > refreshDelay && refresh == true){
                    cx.shadowColor = "blue";
                    cx.fillStyle = "cyan";
                    cx.fillRect(playerX + ml/80 - ml/300, playerY + ml/40 - ml/150, ml/150, ml/150);
                }
                if(ultimaBullet == true){
                    if(bulletCycler < ultimaInterval * 0.95){
                        cx.strokeStyle = primeColor;
                        cx.shadowColor = primeColor;
                    } else{
                        cx.strokeStyle = "darkorchid";
                        cx.shadowColor = "black";
                    }
                    cx.globalAlpha = 0.4;
                    cx.lineWidth = 3;        
                    cx.beginPath();
                    cx.arc(playerX + ml/80, playerY + ml/80, ml/40/ultimaInterval * bulletCycler, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;   
                    cx.globalAlpha = 1;
                }
                if(stunCd > stunDelay && stun == true){
                    if(stunDot == true){
                        cx.shadowColor = "black";
                        cx.strokeStyle = "red";
                    } else{
                        cx.shadowColor = "white";
                        cx.strokeStyle = "gray";
                    }
                    cx.beginPath();
                    cx.arc(playerX + ml/80, playerY + ml/80, ml/40, 0, Math.PI * 2, false);
                    cx.stroke();
                }
                if(smartShotToggle == true){    
                    if(smartFire == 1){
                        cx.strokeStyle = "green";
                        cx.shadowColor = "lime";
                    } else{
                        cx.strokeStyle = primeColor;
                        cx.shadowColor = primeColor;
                    }
                    cx.lineWidth = 3;
                    cx.beginPath();
                    cx.arc(playerX + ml/80, playerY + ml/80, ml/120, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                }
                if(bloodCounter < bloodDuration && bloodSac != 0){
                    cx.strokeStyle = "red";
                    cx.shadowColor = "red";
                    cx.lineWidth = 2;
                    cx.strokeRect(playerX, playerY, ml/40, ml/40);
                    cx.lineWidth = 1;
                } else if(bloodCounter > bloodCooldown && bloodSac != 0){
                    cx.strokeStyle = "red";
                    cx.shadowColor = "red";
                    cx.lineWidth = 2;
                    cx.beginPath();
                    cx.arc(playerX + ml/80, playerY + ml/80, ml/160, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                }
                cx.globalAlpha = 1;    
                if(dashCd >= dashDelay && dash > 0){
                    cx.strokeStyle = primeColor;
                    cx.shadowColor = primeColor;
                    cx.lineWidth = 2;
                    cx.strokeRect(playerX, playerY, ml/40, ml/40);
                    cx.lineWidth = 1;
                } else if(dashCd <= dashDuration){
                    if(dash == 1){
                        cx.strokeStyle = primeColor;
                    } else{
                        cx.strokeStyle = "black";
                    }
                    cx.shadowColor = primeColor;
                    cx.lineWidth = 10;
                    cx.beginPath();
                    cx.moveTo(dashStartX, dashStartY);
                    cx.lineTo(dashEndX, dashEndY);
                    cx.stroke();
                    cx.lineWidth = 1;
                }
                if(shockwaveCd >= 100 && shockwave != 0){
                    if(shockwave == 2 || shockwaveDamage == true){
                        cx.fillStyle = primeColor;
                        cx.shadowColor = primeColor;
                    } else{
                        cx.fillStyle = "firebrick";
                        cx.shadowColor = "hotpink";
                    }
                    cx.beginPath();
                    cx.arc(playerX + ml/80, playerY + ml/80, ml/200, 0, Math.PI * 2);
                    cx.fill();
                } else if (shockwaveCd <= 6){
                    if(shockwave == 2 || shockwaveDamage == true){
                        cx.strokeStyle = primeColor;
                        cx.shadowColor = primeColor;
                    } else{
                        cx.strokeStyle = "firebrick";
                        cx.shadowColor = "hotpink";
                    }
                    cx.lineWidth = 3;
                    cx.beginPath();
                    cx.arc(shockwaveX, shockwaveY, c.width/10, 0, Math.PI * 2, false);
                    cx.stroke();
                    cx.lineWidth = 1;
                }
            }
            cx.globalAlpha = 1;
            if(gameState != 2){
                cx.shadowColor = "red";
                cx.strokeStyle = "pink";
                cx.textAlign = "center";
                cx.font = "35px Arial";
                cx.strokeText(Math.ceil(health) + " / " + maxHealth + " Health", c.width/2, c.height/15);
                cx.shadowColor = "hotpink";
                cx.strokeStyle = "hotpink";
                cx.font = "25px Arial";
                cx.strokeText("Wave: " + wave, c.width/2, c.height/9);
                cx.shadowColor = "gold";
                cx.strokeStyle = "goldenrod";
                cx.strokeText("CyCoins: " + Math.round(cyCoin), c.width/7, c.height/18);
                if(gameState == 0){
                    cx.shadowColor = "red";
                    cx.strokeStyle = "white";
                    cx.strokeText("Kills Remaining: " + (enemyCap - kills), c.width/2, c.height/6.6)
                }
            }
            cx.strokeStyle = "black";
            cx.shadowColor = "cyan";
            cx.strokeRect(3, 3, c.width - 3, c.height - 3);
            if(gameState == 2){
                cx.shadowBlur = 8;
                cx.beginPath();
                cx.fillStyle = "black";
                cx.shadowColor = updateColor;
                cx.arc(c.width/2, c.height/2, c.width/2.41, 0, Math.PI * 2);
                cx.fill();
                cx.shadowColor = "blueviolet";
                cx.fillRect(0, 0, c.width, c.height/4)
                cx.fillRect(c.width/20, c.height/3, c.width/8, c.height/2);
                cx.font = ml/65 + "px Arial";
                cx.strokeStyle = "white";
                cx.lineWidth = 1;
                cx.shadowColor = "blueviolet";
                cx.strokeText("Challenge Points: " + challengePoints , c.width/2, c.height/20);
                cx.lineWidth = 5;
                cx.textAlign = "center";
                cx.shadowColor = updateColor;
                cx.font = ml/12 + "px Arial";
                cx.strokeText("Neon Horde", c.width/2, c.height/2);
                cx.font = ml/65 + "px Arial";
                cx.lineWidth = 1;
                cx.strokeText("The Gamemode Update", c.width/2, c.height/1.8);
                cx.shadowColor = "cyan";
                cx.strokeText("WASD or Arrow Keys to Move", c.width/3, c.height/1.57);
                cx.strokeText("Click to Fire", c.width/3, c.height/1.45);
                cx.strokeText("Q to Toggle Autofire", c.width/3, c.height/1.35);
                cx.strokeText("Space to Buy or Dash", c.width/3, c.height/1.27);
                cx.strokeText("E to Toggle Smartshot", c.width/3, c.height/1.2);
                cx.strokeText("F to Fire Shockwave", c.width/3, c.height/1.135);
                cx.strokeText("Esc to Pause", c.width/3, c.height/1.08);
                cx.strokeText("Z to fire EMP", c.width/3 * 2, c.height/1.57);
                cx.strokeText("X for Blood Boost", c.width/3 * 2, c.height/1.45);
                cx.strokeText("C to Cloak", c.width/3 * 2, c.height/1.35);
                cx.strokeText("R to Refresh Skills", c.width/3 * 2, c.height/1.27);
                cx.strokeText("T to activate Contingency", c.width/3 * 2, c.height/1.2);
                cx.fillStyle = "darkred";
                cx.shadowColor = "white";
                cx.font = c.width/110 + "px Arial";
                cx.fillRect(c.width/60, c.height/30, ml/60, ml/60);
                cx.fillRect(c.width/60, c.height/30 + c.height/20, ml/60, ml/60);
                cx.fillRect(c.width/60, c.height/30 + c.height/10, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/8 + c.width/15.6, c.height/30, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/8 + c.width/15.6, c.height/30 + c.height/20, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/8 + c.width/15.6, c.height/30 + c.height/10, ml/60, ml/60);
                cx.fillStyle = "darkgreen";
                cx.fillRect(c.width/60 + c.width/8, c.height/30, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/8, c.height/30 + c.height/20, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/8, c.height/30 + c.height/10, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/4 + c.width/15.6, c.height/30, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/4 + c.width/15.6, c.height/30 + c.height/20, ml/60, ml/60);
                cx.fillRect(c.width/60 + c.width/4 + c.width/15.6, c.height/30 + c.height/10, ml/60, ml/60);
                cx.fillStyle = "gray";
                cx.strokeText("Enemy Spawn Rate", c.width/60 + c.width/14, c.height/18);
                cx.strokeText("Enemy Damage", c.width/60 + c.width/14, c.height/18 + c.height/20);
                cx.strokeText("Enemy HP", c.width/60 + c.width/14, c.height/18 + c.height/10);
                cx.strokeText("Money Gain", c.width/60 + c.width/3.8, c.height/18);
                cx.strokeText("Enemy Speed", c.width/60 + c.width/3.8, c.height/18 + c.height/20);
                cx.strokeText("Unique Cap", c.width/60 + c.width/3.8, c.height/18 + c.height/10);
                cx.fillStyle = "black";
                cx.fillRect(c.width/100 * 60, c.height/20, c.width/8, c.height/8);
                switch(gameMode){
                    case 0:
                        cx.strokeText("Gamemode: Standard", c.width/100 * 60 + c.width/16, c.height/8.5);
                        break;
                    case 1:
                        cx.strokeText("Gamemode: Random", c.width/100 * 60 + c.width/16, c.height/8.5);
                        break;
                    case 2:
                        cx.strokeText("Gamemode: Classic+", c.width/100 * 60 + c.width/16, c.height/8.5);
                        break;
                }
                cx.fillStyle = "gray";
                cx.shadowColor = "cyan";
                cx.fillStyle = "black";
                cx.font = ml/50 + "px Arial";
                cx.fillRect(c.width/2 - c.width/16, c.height/10, c.width/8, c.height/12);
                cx.strokeStyle = "white";
                cx.lineWidth = ml/1500;
                cx.strokeText("Begin", c.width/2, c.height/10 + c.height/18);
                cx.font = c.width/100 + "px Arial";
                switch(menuInspecting){
                    case 0:
                        cx.shadowColor = "purple";
                        cx.strokeText("Prepare your journey.", c.width/20 + c.width/16, c.height/3 + 30);
                        break;
                    case 1:
                        menuDescription(c.width/2 - c.width/16, c.height/10, c.width/8, c.height/12, "Embark against the horde.");
                        break;
                    case 2:
                        menuDescription(c.width/60, c.height/30, ml/60, ml/60, "Decrease the rate of enemy spawn. Current: Every " + enemyDelay + " Frame(s).");
                        break;
                    case 3:
                        menuDescription(c.width/60 + c.width/8, c.height/30, ml/60, ml/60, "Increase the rate of enemy spawn. Current: Every " + enemyDelay + " Frame(s).");
                        break;
                    case 4:
                        menuDescription(c.width/60, c.height/30 + c.height/20, ml/60, ml/60, "Decrease the damage that enemies deal. Current: " + Math.round(eDmgMulti * 10)/10 + "x.");
                        break;
                    case 5:
                        menuDescription(c.width/60 + c.width/8, c.height/30 + c.height/20, ml/60, ml/60, "Increase the damage that enemies deal. Current: " + Math.round(eDmgMulti * 10)/10 + "x.");
                        break;
                    case 6:
                        menuDescription(c.width/60, c.height/30 + c.height/10, ml/60, ml/60, "Decrase the hp of all enemies. Current: " + Math.round(eHpMulti * 10)/10 + "x.");
                        break;
                    case 7:
                        menuDescription(c.width/60 + c.width/8, c.height/30 + c.height/10, ml/60, ml/60, "Increase the hp of all enemies. Current: " + Math.round(eHpMulti * 10)/10 + "x.");
                        break;
                    case 8:
                        menuDescription(c.width/60 + c.width/8 + c.width/15.6, c.height/30, ml/60, ml/60, "Decrease the amount of coins enemies drop. Current: " + Math.round(moneyGain * 10)/10 + "x.");
                        break;
                    case 9:
                        menuDescription(c.width/60 + c.width/4 + c.width/15.6, c.height/30, ml/60, ml/60, "Increase the amount of coins enemies drop. Current: " + Math.round(moneyGain * 10)/10 + "x.");
                        break;
                    case 10:
                        menuDescription(c.width/60 + c.width/8 + c.width/15.6, c.height/30 + c.height/20, ml/60, ml/60, "Decrease the speed of enemies. Current: " + Math.round(eSpeedMulti * 10)/10 + "x.");
                        break;
                    case 11:
                        menuDescription(c.width/60 + c.width/4 + c.width/15.6, c.height/30 + c.height/20, ml/60, ml/60, "Increase the speed of enemies. Current: " + Math.round(eSpeedMulti * 10)/10 + "x.");
                        break;
                    case 12:
                        menuDescription(c.width/60 + c.width/8 + c.width/15.6, c.height/30 + c.height/10, ml/60, ml/60, "Decrease the amount of uniques you are allowed to purchase. Current:  All but " + uniqueCap + " unique(s).");
                        break;
                    case 13:
                        menuDescription(c.width/60 + c.width/4 + c.width/15.6, c.height/30 + c.height/10, ml/60, ml/60, "Increase the amount of uniques you are allowed to purchase. Current: All but " + uniqueCap + " unique(s).");
                        break;
                    case 14:
                        switch(gameMode){
                            case 0:
                                menuDescription(c.width/100 * 60, c.height/20, c.width/8, c.height/8, "Standard is the proper way to experience neon horde, choosing 1 of 4 factions to determine your items. Click to switch.");
                                break;
                            case 1:
                                menuDescription(c.width/100 * 60, c.height/20, c.width/8, c.height/8, "Be offered a random set of 16 unique items. This is not balanced in the slightest. Click to switch.");
                                break;
                            case 2:
                                menuDescription(c.width/100 * 60, c.height/20, c.width/8, c.height/8, "Classic+ is an expanded version of the original system. Gain access to every single unique item throughout the run, becoming extremely and overly powerful. Click to switch.");
                                break;
                        }
                        break;
                }
            }  
            if(gameState == 3){
                cx.lineWidth = 5;
                cx.textAlign = "center";
                cx.font = ml/18 + "px Arial";
                cx.shadowColor = "red";
                cx.strokeStyle = "#242424";
                cx.strokeText("Game Over", c.width/2, c.height/100 * 20);
                cx.lineWidth = 1;
                cx.font = ml/55 + "px Arial";
                cx.shadowColor = "cyan";
                cx.strokeStyle = "white";
                cx.strokeText("Total Kills: " + totalKills, c.width/2, c.height/100 * 25);
                cx.strokeText("Total CyCoins Earned: " + totalCoins, c.width/2, c.height/100 * 30);
                cx.strokeText("Waves Completed: " + (wave - 1), c.width/2, c.height/100 * 35);
                cx.strokeText("Items Purchased: " + itemsPurchased, c.width/2, c.height/100 * 40);
                cx.shadowColor = "purple";
                cx.strokeText("Challenge Points: " + challengePoints, c.width/2, c.height/100 * 45);
                cx.lineWidth = 2;
                cx.shadowColor = "gold";
                cx.strokeStyle = "yellow";
                cx.strokeText("Press Space to Restart", c.width/2, c.height/100 * 80);
                cx.shadowBlur = 8;
                cx.shadowColor = "cyan";
                cx.lineWidth = 1.5;
                cx.strokeStyle = "white";
                cx.font = c.height/50 + "px Arial";
                cx.strokeText("Max HP: " + maxHealth, c.width - c.width/14, c.height/100 * 4);
                cx.strokeText("Damage: " + damage + " (" + damageMulti + "X)", c.width - c.width/14, c.height/100 * 8);
                cx.strokeText("Move Speed: " + (playerSpeed * 2), c.width - c.width/14, c.height/100 * 12);
                cx.strokeText("Attack Speed: " + (120 - Math.round(attackSpeed*10)), c.width - c.width/14, c.height/100 * 16);
                cx.strokeText("Regen/Round: " + roundRegen + " (" + roundRegenMulti + "X)", c.width - c.width/14, c.height/100 * 20);
                cx.shadowColor = "purple";
                cx.strokeText("Enemy HP: " + Math.round(eHpMulti * 10)/10 + "x", c.width - c.width/14, c.height/100 * 24);
                cx.strokeText("Enemy DMG: " + Math.round(eDmgMulti * 10)/10 + "x", c.width - c.width/14, c.height/100 * 28);
                cx.strokeText("Move Speed: " + Math.round(eSpeedMulti * 10)/10 + "x", c.width - c.width/14, c.height/100 * 32);
                cx.strokeText("Enemy Spawn Rate: " + startDelay, c.width - c.width/14, c.height/100 * 36);
                cx.strokeText("Money Gain: " + Math.round(moneyGain * 10)/10 + "x", c.width - c.width/14, c.height/100 * 40);
                cx.strokeText("Unique Limit: " + startCap, c.width - c.width/14, c.height/100 * 44);
            }
            if(pause == true){
                cx.lineWidth = 5;
                cx.textAlign = "center";
                cx.font = "200px Arial";
                cx.shadowColor = "cyan";
                cx.strokeStyle = "white";
                cx.strokeText("Paused", c.width/2, c.height/3.5);
                cx.font = "30px Arial";
                cx.lineWidth = 1;
                cx.strokeText("Press Escape to Resume", c.width/2, c.height/2.7);
                cx.strokeText("WASD or Arrow Keys to Move", c.width/3, c.height/1.57);
                cx.strokeText("Click to Fire", c.width/3, c.height/1.45);
                cx.strokeText("Q to Toggle Autofire", c.width/3, c.height/1.35);
                cx.strokeText("Space to Buy or Dash", c.width/3, c.height/1.27);
                cx.strokeText("E to Toggle Smartshot", c.width/3, c.height/1.2);
                cx.strokeText("F to Fire Shockwave", c.width/3, c.height/1.135);
                cx.strokeText("Esc to Pause", c.width/3, c.height/1.08);
                cx.strokeText("Z to fire EMP", c.width/3 * 2, c.height/1.57);
                cx.strokeText("X for Blood Boost", c.width/3 * 2, c.height/1.45);
                cx.strokeText("C to Cloak", c.width/3 * 2, c.height/1.35);
                cx.strokeText("R to Refresh Skills", c.width/3 * 2, c.height/1.27);
                cx.strokeText("T to activate Contingency", c.width/3 * 2, c.height/1.2);
            }
        }
        function descriptionHandler(name, description, priceVariable, strokeColor, shadowColor){
            let tempslotlength = 0;
            switch(slotinspecting){
                case 1:
                    tempslotlength = slot1.length;
                    break;
                case 2:
                    tempslotlength = slot2.length;
                    break;
                case 3:
                    tempslotlength = slot3.length;
                    break;
                case 4:
                    tempslotlength = slot4.length;
                    break;
                case 5:
                    tempslotlength = slot5.length;
                    break;
                case 6:
                    tempslotlength = slot6.length;
                    break;
            }
            cx.strokeStyle = strokeColor;
            cx.shadowColor = shadowColor;
            if(name != "Repair Nanobots"){
                cx.strokeText(name + " (" + (slotlengths[slotinspecting - 1] - tempslotlength + 1) + "/" + slotlengths[slotinspecting - 1] + ")", c.width/7, c.height/100 * 15);
            } else{
                cx.strokeText(name, c.width/7, c.height/100 * 15);
            }
            let offset = 0;
            let runCount = 0;
            cx.strokeStyle = "lime";
            cx.shadowColor = "green";
            for(let i = 0; i <= description.length; i++){
                if(description.charAt(i) == " " && i - offset > 15 || i == description.length){
                    runCount++;
                    cx.strokeText(description.substr(offset, i - offset), c.width/7, c.height/100 * (20 + runCount * 5));
                    offset = i;
                }
            }
            if(cyCoin < priceVariable){
                cx.strokeStyle = "hotpink";
                cx.shadowColor = "red";
                cx.strokeText("Insufficent Funds", c.width/7, c.height/100 * 80); 
            }
            cx.strokeStyle = "gold";
            cx.shadowColor = "goldenrod";
            cx.strokeText("Price: " + priceVariable + " CyCoins", c.width/7, c.height/100 * 90);
            cx.strokeText("Press Space to Buy", c.width/7, c.height/100 * 95);
        }
        function menuDescription(xpos, ypos, width, height, description){
            cx.fillStyle = "white";
            cx.globalAlpha = 0.1;
            cx.fillRect(xpos, ypos, width, height);
            cx.shadowColor = "purple";
            cx.globalAlpha = 1;
            let offset = 0;
            let runCount = 0;   
            for(let i = 0; i <= description.length; i++){
                if(description.charAt(i) == " " && i - offset > 15 || i == description.length){
                    runCount++;
                    cx.strokeText(description.substr(offset, i - offset), c.width/20 + c.width/16, c.height/100 * (33 + runCount * 3));
                    offset = i;
                }
            }
        }
	    function shootStore(){
	        mouseX = event.offsetX - c.width/80;
	        mouseY = event.offsetY - c.width/80;
            if(gameState == 2){
                menuHandler();
            }
	    }
        function touchShoot(){
            mouseX = event.changedTouches[0].screenX;
            mouseY = event.changedTouches[0].screenY;
            if(gameState == 2){
                menuHandler();
            }
        }
        function menuHandler(){
            if(buttoner(c.width/2 - c.width/16, c.height/10, c.width/8, c.height/12) == true){
                menuInspecting = 1;
            } else if (buttoner(c.width/60, c.height/30, ml/60, ml/60) == true){
                menuInspecting = 2;
            } else if (buttoner(c.width/60 + c.width/8, c.height/30, ml/60, ml/60) == true){
                menuInspecting = 3;
            } else if (buttoner(c.width/60, c.height/30 + c.height/20, ml/60, ml/60) == true){
                menuInspecting = 4;
            } else if (buttoner(c.width/60 + c.width/8, c.height/30 + c.height/20, ml/60, ml/60) == true){
                menuInspecting = 5;
            } else if (buttoner(c.width/60, c.height/30 + c.height/10, ml/60, ml/60) == true){
                menuInspecting = 6;
            } else if (buttoner(c.width/60 + c.width/8, c.height/30 + c.height/10, ml/60, ml/60) == true){
                menuInspecting = 7;
            } else if (buttoner(c.width/60 + c.width/8 + c.width/15.6, c.height/30, ml/60, ml/60) == true){
                menuInspecting = 8;
            } else if (buttoner(c.width/60 + c.width/4 + c.width/15.6, c.height/30, ml/60, ml/60) == true){
                menuInspecting = 9;
            } else if (buttoner(c.width/60 + c.width/8 + c.width/15.6, c.height/30 + c.height/20, ml/60, ml/60) == true){
                menuInspecting = 10;
            } else if (buttoner(c.width/60 + c.width/4 + c.width/15.6, c.height/30 + c.height/20, ml/60, ml/60) == true){
                menuInspecting = 11;
            } else if (buttoner(c.width/60 + c.width/8 + c.width/15.6, c.height/30 + c.height/10, ml/60, ml/60) == true){
                menuInspecting = 12;
            } else if (buttoner(c.width/60 + c.width/4 + c.width/15.6, c.height/30 + c.height/10, ml/60, ml/60) == true){
                menuInspecting = 13;
            } else if (buttoner(c.width/100 * 60, c.height/20, c.width/8, c.height/8) == true){
                menuInspecting = 14;
            } else{
                menuInspecting = 0;
            }
        }
        function buttoner(xpos, ypos, width, height){
            if(mouseX + c.width/80 > xpos && mouseX + c.width/80 < xpos + width && mouseY + c.width/80 > ypos && mouseY + c.width/80 < ypos + height){
                return true;
            } else{
                return false;
            }
        }
        function shoot(){
            if(smartShotToggle == true && gameState == 0){
                if(smartFire == 1){
                    if(targetSwitch == true){
                        randomShotTarget = Math.floor(Math.random() * enemyX.length);
                        targetSwitch = false;
                    }
                    mouseX = enemyX[randomShotTarget];
                    mouseY = enemyY[randomShotTarget];
                } else{
                    mouseX = 0;
                    mouseY = 0;
                    for(let i = 0; i < enemyX.length; i++){
                        if(Math.abs(enemyX[i] - playerX) + Math.abs(enemyY[i] - playerY) <= Math.abs(mouseX - playerX) + Math.abs(mouseY - playerY)){
                            mouseX = enemyX[i];
                            mouseY = enemyY[i];
                        }
                    }
                }
            }
            bullXMomentum.push((mouseX - playerX)/(Math.abs(mouseY - playerY) + Math.abs(mouseX - playerX)));
            bullYMomentum.push((mouseY - playerY)/(Math.abs(mouseY - playerY) + Math.abs(mouseX - playerX)));
            bulletConsistencyLauncher();
            if(summmitStar == true){
                if(summitCircler >= 0.5){
                    summitCircler += -0.01;
                } else{
                    summitCircler = 1;
                }
                bullXMomentum.push(summitCircler);
                bullYMomentum.push(1 - summitCircler);
                bullXMomentum.push(-summitCircler);
                bullYMomentum.push(summitCircler - 1);
                bullXMomentum.push(summitCircler - 1);
                bullYMomentum.push(summitCircler);
                bullXMomentum.push(1 - summitCircler);
                bullYMomentum.push(-summitCircler);
                bullXMomentum.push(summitCircler - 0.5);
                bullYMomentum.push(1.5 - summitCircler);
                bullXMomentum.push(0.5 - summitCircler);
                bullYMomentum.push(summitCircler - 1.5);
                bullXMomentum.push(1.5 - summitCircler);
                bullYMomentum.push(0.5 - summitCircler);
                bullXMomentum.push(summitCircler - 1.5);
                bullYMomentum.push(summitCircler - 0.5);
                for(let i = 0; i < 8; i++){
                    bulletConsistencyLauncher();
                }
            }
            if(zenithFirestorm == true){
                bullXMomentum.push((playerY - mouseY)/(Math.abs(playerY - mouseY) + Math.abs(playerX - mouseX)));
                bullYMomentum.push((playerX - mouseX)/(Math.abs(playerY - mouseY) + Math.abs(playerX - mouseX)));
                bullXMomentum.push((mouseY - playerY)/(Math.abs(mouseY - playerY) + Math.abs(mouseX - playerX)));
                bullYMomentum.push((mouseX - playerX)/(Math.abs(mouseY - playerY) + Math.abs(mouseX - playerX)));
                randomShot = Math.random();
                if(Math.floor(Math.random() * 2) == 1){
                    bullXMomentum.push(randomShot);
                } else{
                    bullXMomentum.push(-randomShot);
                }
                if(Math.floor(Math.random() * 2) == 1){
                    bullYMomentum.push(1 - randomShot);
                } else{
                    bullYMomentum.push(randomShot - 1);
                }
                for(let i = 0; i < 3; i++){
                    bulletConsistencyLauncher();
                }
            }
            if(chaosCore == true){
                randomShot = Math.random();
                if(Math.floor(Math.random() * 2) == 1){
                    bullXMomentum.push(randomShot);
                } else{
                    bullXMomentum.push(-randomShot);
                }
                if(Math.floor(Math.random() * 2) == 1){
                    bullYMomentum.push(1 - randomShot);
                } else{
                    bullYMomentum.push(randomShot - 1);
                }
                bulletConsistencyLauncher();
            }
            if(doubleshot == true){
                bullXMomentum.push((playerX - mouseX)/(Math.abs(playerY - mouseY) + Math.abs(playerX - mouseX)));
                bullYMomentum.push((playerY - mouseY)/(Math.abs(playerY - mouseY) + Math.abs(playerX - mouseX)));
                bulletConsistencyLauncher();
            }
            function bulletConsistencyLauncher(){
                bullXPos.push(playerX + ml/80);
                bullYPos.push(playerY + ml/80);
                if(bulletCycler % ultimaInterval == 0 && ultimaBullet == true && bulletCycler != 0){
                    for(let i = 0; i < enemyX.length/2; i++){
                        kill(i);
                    }
                    enemies = 0;
                    enemyX.length = 0;
                    enemyY.length = 0;
                    enemyMulti.length = 0;
                    enemyStatus.length = 0;
                    bulletProperties.push(4);
                    bulletCycler = 0;
                } else if(bulletCycler % healInterval == 0 && extractBullet == true){
                    bulletProperties.push(5);
                } else if(bulletCycler % sharpInterval == 0 && sharpBullet == true){
                    bulletProperties.push(3);
                } if(bulletCycler % hardInterval == 0 && hardBullet == true){
                    bulletProperties.push(2);
                } else if(bulletCycler % freezeInterval == 0 && freezeBullet == true){
                    bulletProperties.push(1);
                } else{
                    bulletProperties.push(0);
                }
                bulletCycler++;
            }
        }
        function droneShooter(){
                for(let i = 0; i < droneX.length; i++){
                    droneXTarget[i] = 10000;
                    droneYTarget[i] = 10000;
                    for(let t = 0; t < enemyX.length; t++){
                        if(Math.abs(enemyX[t] - droneX[i]) + Math.abs(enemyY[t] - droneY[i]) <= Math.abs(droneXTarget[i] - droneX[i]) + Math.abs(droneYTarget[i] - droneY[i])){
                            droneXTarget[i] = enemyX[t] + ml/100;
                            droneYTarget[i] = enemyY[t] + ml/100;
                        }
                    }
                    bullXMomentum.push((droneXTarget[i] - droneX[i])/(Math.abs(droneYTarget[i] - droneY[i]) + Math.abs(droneXTarget[i] - droneX[i])));
                    bullYMomentum.push((droneYTarget[i] - droneY[i])/(Math.abs(droneYTarget[i] - droneY[i]) + Math.abs(droneXTarget[i] - droneX[i])));
                    bullXPos.push(droneX[i] + ml/100);
                    bullYPos.push(droneY[i] + ml/100);
                    bulletProperties.push(0);
                }
            }
    </script>
</html>