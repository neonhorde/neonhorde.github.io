<!DOCTYPE html>
<html>
    <head>
        <title>Neon Horde: Rebirth</title>
        <link rel = "icon" href = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Neon_discharge_tube.jpg/220px-Neon_discharge_tube.jpg">
    </head>
    <body style = "margin: 0 !important; padding: 0 !important">
        <canvas style = "background-color: black; display: block;" id = "gamescreen"></canvas>
    </body>
    <script>
        const c = document.getElementById("gamescreen");
        const cx = c.getContext("2d");
        let ml;
        let devMode = false;
        let playerSize = 25;
        let bulletSize = 10;
        let playerYDirect = 0;
        let playerXDirect = 0;
        let playerSpeed = 5;
        let playerProjectiles = 1;
        let moving = false;
        let selfBulletDamage = false;
        let shotSpread = 0;
        let movingRamMulti = 1;
        let movingContactReduction = 1;
        let shotDelay = 400;
        let curseCircleSize = 70;
        let curseCircleSpeed = 0.9; 
        let globalLifeSteal = 0;
        let healthDegrade = 0;
        let overhaul = false;
        let curseChance = 0.005;
        let curseChanceLoss = 0.5;
        let bounceChance = 0;
        let bounceTimes = 0;
        let pierceChance = 0;
        let pierceLoss = 1;
        let wave = 1; //max 9224 else enemy hp is infinite
        let fragmentBullets = 0;
        let fragmentDamage = 0.3;
        let recursiveFragments = false; //DO NOT ENABLE THIS THIS IS DEATH IT WILL LITERALLY CRASH CHROME DO NOT DO NOT DO NOT
        let bulletDuration = 30;
        let bulletDurationMulti = 1;
        let bulletSpeed = 20;
        let level = 1;
        let playerDamage = 5;
        let playerDamageMulti = 1;
        let additivePlayerDamageMulti = 1;
        let maxHpPerLevel = 3;
        let maxHealth = 25 + (level - 1) * maxHpPerLevel;
        let maxShield = 0
        let shield = maxShield
        let shieldAttackSpeedBonus = 1
        let shieldBreakAoeDamage = 0
        let shieldBreakAoeDuration = 3000
        let shieldBreakAoeSize = 100
        let shieldRegenDelay = 5
        let shieldRegenTime = 3
        let iframes = 300;
        let lastKillType;
        let roundRegen = 0;
        let levelRegen = 0;
        let combatRegen = 0;
        let regenDelay = 5;
        let baseSpawnTime = 1000;
        let deathMissleDamage = 0;
        let critChance = 0;
        let critShadowChance = 0;
        let critAoeDuration = 0;
        let critAoeSize = 10;
        let critAoeDamage = 1;
        let critDamage = 2;
        let enemyCap = 20;
        let maxAccelBonus = 1;
        let damageReduction = 1;
        let contactDamageReduction = 1;
        let dotDamageReduction = 1;
        let projectileDamageReduction = 1;
        let delayedContactHealing = 0;
        let rammingDamage = 1;
        let baseRammingDamage= 10;
        let speedStatMulti = 0;
        let rammingGains = 0;
        let rammingLosses = 0;
        let rammingIframes = 1;
        let rammingKillSteal = 0;
        let rammingImmunityTime = 0;
        let largeDamageHealing = 0;
        let largeDamageThreshold = 4;
        let projectileIframes = 1;
        let storedRammingHP = 0;
        let chainRamming = 1;
        let chainRammingTime = 0.5;
        let DCHtime = 4;
        let currentDCH = 0;
        let storedDCH = currentDCH;
        let invulnerable = false;
        let health = maxHealth;
        let shotAvailable = false;
        let shooting = false;
        let xp = 0;
        let autofire = false;
        let waveActive = true;
        let spawnFinish = -waveActive;
        if(devMode){
            xp = 1000000000000000000000000000000000000;
            waveActive = false;
            spawnFinish = true;
            wave = 50;
        }
        let enemyHpScaling = 1.1;
        let enemyDamageScaling = 1.04;
        let globalEnemyHP = 1 * Math.pow(enemyHpScaling, wave - 1);
        let globalEnemyDamage = 1 * Math.pow(enemyDamageScaling, wave - 1);;
        let enemyCount = 0;
        let skillIDCounter = 0;
        let mlhr = 0;
        let extraShots = 0;
        let extraShotChance = 0;
        let killTime = 0;
        let damageTime = 0;
        let gameOver = false;
        let pause = false;
        let directorAggression = 1 + (wave - 1) * 0.1;
        let directorCreditMulti = 50;
        let baseCredits = 75;
        let directorCredits = baseCredits + (wave - 1) * directorCreditMulti;
        let waveDelay = 100; //delay in seconds between waves
        let mouseX = 0;
        let mouseY = 0;
        let kills = 0;
        let killedCost = 0;
        let deathBurstIncrease = 1.5;
        let requiredXP = 14;
        let xpGain = 1;
        let multiplicativeXpGain = 1;
        let xpGrowth = 1.08;
        let deathBurstDuration = 0;
        let totalXP = xp;
        let preGameCycler = false;
        let totalWeight = 0;
        let enemyWaveCounter = 0;
        let standardAlpha = 1;
        let additionalSkillPoints = 0;
        let skillPoints = level - 1;
        let rerolls = Math.floor(wave/3);
        let waveDelayCounter = 0;
        let looperBullets = false;
        let minCost;
        let bulletCounter = 0;
        let playerBuffs;
        let inspecting = 0;
        let inspectingTarget = 0;
        var markedBullets = [];
        const totalItemList = [];
        const availableItemList = [];
        const offeredItems = [];
        const purchasedItems = [];
        const enemyStatBlock = [];
        const availableEnemies = [];
        const bullets = [];
        const bss = [];
        const bullProperties = [];
        const bulletTrackerID = [];
        const enemies = [];
        const ess = [];
        const enemyTrackerID = [];
        const lasers = [];
        const lss = [];
        const laserTrackerID = [];
        const aoes = [];
        const areass = [];
        const aoeTrackerID = [];
        const items = [];
        window.addEventListener("resize", resize, false);
        window.addEventListener("keydown", keyhandler, false);
        window.addEventListener("keyup", movestopper, false);
        window.addEventListener("mousedown", clickhandler, false);
        window.addEventListener("mouseup", shotstopper, false);
        window.addEventListener("mousemove", mousehandler, false);
        function clickhandler(){
            shooting = true;
            if(inspecting != 0 && pause == true && skillPoints > 0 && offeredItems[inspecting - 1] !== undefined && inspectingTarget == 1){
                skillPoints--;
                offeredItems[inspecting - 1].buy();
                if(totalItemList[offeredItems[inspecting - 1].trackerID].purchased == 0){
                    purchasedItems.push(offeredItems[inspecting - 1])
                }
                totalItemList[offeredItems[inspecting - 1].trackerID].purchased++;
                itemRoll();
            } else if(inspectingTarget == 3){
                if (pause == true && rerolls > 0){
                    itemRoll();
                    rerolls--;
                }
            }
        }
        function shotstopper(){
            shooting = false;
        }
        function mousehandler(){
            mouseX = event.offsetX;
            mouseY = event.offsetY;
            if(pause == true){
                shopHandler();
            }
        }
        function shopHandler(){
            if(squareHitCornerDetector(mouseX, mouseY, 0, 0, c.width * 0.45 - ml * 0.1, c.height * 0.3, ml * 0.1, ml * 0.1)){
                inspectingTarget = 1;
                inspecting = 1;
            } else if (squareHitCornerDetector(mouseX, mouseY, 0, 0, c.width * 0.55, c.height * 0.3, ml * 0.1, ml * 0.1)){
                inspectingTarget = 1;
                inspecting = 2;
            } else if (squareHitCornerDetector(mouseX, mouseY, 0, 0, c.width * 0.45 - ml * 0.1, c.height * 0.6, ml * 0.1, ml * 0.1)){
                inspectingTarget = 1;
                inspecting = 3;
            } else if (squareHitCornerDetector(mouseX, mouseY, 0, 0, c.width * 0.55, c.height * 0.6, ml * 0.1, ml * 0.1)){
                inspectingTarget = 1;
                inspecting = 4;
            } else if (squareHitCornerDetector(mouseX, mouseY, 0, 0, c.width * 0.45, c.height * 0.15, c.width * 0.1, c.height * 0.05)){
                inspectingTarget = 3;
                inspecting = 0;
            } else{
                inspectingTarget = 0;
                inspecting = 0;
                for(let i = 0; i < purchasedItems.length; i++){
                    if(squareHitCornerDetector(mouseX, mouseY, 0, 0, ml/30 * Math.floor(i/mlhr), ml/40 * (i - Math.floor(i/mlhr) * mlhr) + ml/100, ml/50, ml/50)){
                        inspecting = i;
                        inspectingTarget = 2;
                        break;
                    }
                }
            }
        }
        function squareHitCornerDetector(x1, y1, w1, h1, x2, y2, w2, h2){
            return x1 + w1 > x2 && x1 < x2 + w2 && y1 + h1 > y2 && y1 < y2 + h2;
        }
        function keyhandler(){
            switch(event.code){
                case "Digit1":
                case "Digit2":
                case "Digit3":
                case "Digit4":
                    let target = parseInt(event.key) - 1;
                    if(skillPoints > 0 && pause == true && offeredItems[target] !== undefined){
                        skillPoints--;
                        offeredItems[target].buy();
                        if(totalItemList[offeredItems[target].trackerID].purchased == 0){
                            purchasedItems.push(offeredItems[target])
                        }
                        totalItemList[offeredItems[target].trackerID].purchased++;
                        itemRoll();
                    }
                    break;
                case "KeyW":
                    playerYDirect = -1;
                    break;
                case "KeyS":
                    playerYDirect = 1;
                    break;
                case "KeyD":
                    playerXDirect = 1;
                    break;
                case "KeyA":
                    playerXDirect = -1;
                    break;
                case "KeyQ":
                    if(autofire == false){
                        autofire = true;
                    } else{
                        autofire = false;
                    }
                    break;
                case "KeyR":
                    if(gameOver == true){
                        location.reload();
                    } else if (pause == true && rerolls > 0){
                        itemRoll();
                        rerolls--;
                    }
                    break;
                case "KeyE":
                    if(pause == false && waveActive == false){
                        pause = true;
                        standardAlpha = 0.5;
                    } else{
                        pause = false;
                        standardAlpha = 1;
                    }
                    break;
                case "KeyZ":
                    if(waveActive == false && pause == false){
                        waveDelayCounter = waveDelay * 50;
                    }
                    break;
            }
        }
        function movestopper(){
            if(event.code == "KeyW" || event.code == "KeyS"){
                playerYDirect = 0;
            } else if (event.code == "KeyD" || event.code == "KeyA"){
                playerXDirect = 0;
            }
        }
        function bulletSideStats(xmom, ymom, damage, speed, duration, owner){
            this.xmom = xmom;
            this.ymom = ymom;
            this.damage = damage;
            this.speed = speed;
            this.duration = duration;
            this.owner = owner;
            this.originalDamage = damage;
            this.interacting = [];
        }
        function playerBuffStats(){
            this.deathBurst = 0;
        }
        function enemySideStats(type, shotavailable, currenthp, skillavailable){
            this.hp = currenthp;
            this.type = type;
            this.shotavailable = shotavailable;
            this.skillavailable = skillavailable;
            this.skillactive = [];
            this.randomPosX = Math.random();
            this.randomPosY = Math.random();
            this.healthBarCounter = 0;
            this.randomChooser = randomInt(1, 2);
            this.shotAngle = enemyStatBlock[this.type].shotMinAngle;
            this.cycleCount = 0;
            this.shooting = false;
        }
        function laserSideStats(duration, damage, length, enemyorigintrackerid, xdirect, ydirect, type, changetype, angle){
            this.duration = duration;
            this.damage = damage;
            this.longness = length;
            this.eoti = enemyorigintrackerid;
            this.xdirect = xdirect;
            this.ydirect = ydirect;
            this.type = type;
            this.changetype = changetype;
            this.angle = angle;
            this.originalAngle = angle;
        }
        function areasSideStats(duration, damage, healing, enemyorigintrackerid, damageconsume, healconsume){
            this.duration = duration;
            this.damage = damage;
            this.healing = healing;
            this.eoti = enemyorigintrackerid;
            this.damageconsume = damageconsume;
            this.healconsume = healconsume;
        }
        function bulletProperties(looper, bouncy, bouncyAmount, fragmenting, piercing){
            this.looping = looper;
            this.bouncing = bouncy;
            this.bouncesLeft = bouncyAmount;
            this.fragmenting = fragmenting;
            this.cycler = 1;
            this.piercing = piercing;
        }
        class itemHolder{
            constructor(id){
                this.trackerID = id;
                this.purchased = 0;
                this.boxStyle = 'cyan';
                this.boxGlowStyle = 'blue';
                switch(id){
                    case 0:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Forged Bullets";
                        this.maxPurchases = 5;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Increases your base damage by 1.", "Max Stacks: " + this.maxPurchases, "Purchased: " + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            playerDamage++;
                            this.baseCopies += 10;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "white";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "white";
                            cx.shadowColor = "red";
                            cx.lineWidth = ml * 0.001 * size;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.02 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.closePath();
                        }
                        break;
                    case 1:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "XP Osmosis";
                        this.maxPurchases = 5;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Increases xp gain by 10%, additively.", "Max Stacks: " + this.maxPurchases, "Purchased: " + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            xpGain += 0.1;
                            this.baseCopies += 10;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "blue";
                            cx.lineWidth = ml * 0.002 * size;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.04 * size, yoffset + ml * 0.04 * size, ml * 0.005 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.06 * size, yoffset + ml * 0.06 * size, ml * 0.005 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.04 * size, yoffset + ml * 0.06 * size, ml * 0.005 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.06 * size, yoffset + ml * 0.04 * size, ml * 0.005 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.closePath();
                        }
                        break;
                    case 2:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Charged Weaponry";
                        this.maxPurchases = 5;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Increase attack speed by 15%, multiplicatively.", "Max Stacks: " + this.maxPurchases, "Purchased: " + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            shotDelay = shotDelay * 0.85;
                            this.baseCopies += 10;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.04 * size, ml * 0.05 * size, ml * 0.02 * size);
                            cx.fillStyle = "cyan";
                            cx.fillRect(xoffset + ml * 0.065 * size, yoffset + ml * 0.04 * size, ml * 0.01 * size, ml * 0.02 * size);
                        }
                        break;
                    case 3:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Twin Thrusters";
                        this.maxPurchases = 5;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Increases your base move speed by 1.", "Max Stacks: " + this.maxPurchases, "Purchased: " + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            playerSpeed += 1;
                            this.baseCopies += 10;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.01 * size, yoffset + ml * 0.025 * size, ml * 0.02 * size, ml * 0.05 * size);
                            cx.fillRect(xoffset + ml * 0.07 * size, yoffset + ml * 0.025 * size, ml * 0.02 * size, ml * 0.05 * size);
                            cx.fillStyle = "orange";
                            cx.shadowColor = "orange";
                            cx.fillRect(xoffset + ml * 0.01 * size, yoffset + ml * 0.065 * size, ml * 0.02 * size, ml * 0.01 * size);
                            cx.fillRect(xoffset + ml * 0.07 * size, yoffset + ml * 0.065 * size, ml * 0.02 * size, ml * 0.01 * size);
                        }
                        break;
                    case 4:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Engineering Manual";
                        this.maxPurchases = 2;
                        this.baseCopies = 100;
                        this.description = function(){
                            return ["Every 5 levels, gain an additional skill point.", "Max Stacks: " + this.maxPurchases, "Purchased: " + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[1].purchased >= 3;
                        }
                        this.buy = function(){
                            additionalSkillPoints++;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.008 * size, yoffset + ml * 0.025 * size, ml * 0.04 * size, ml * 0.05 * size);
                            cx.fillRect(xoffset + ml * 0.052 * size, yoffset + ml * 0.025 * size, ml * 0.04 * size, ml * 0.05 * size);
                        }
                        break;
                    case 5:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Bullet Boosters";
                        this.maxPurchases = 5;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Increases your base bullet speed by 4.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            bulletSpeed += 5;
                            this.baseCopies += 10;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "white";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.025 * size, ml * 0.02 * size, ml * 0.05 * size);
                            cx.fillStyle = "red";
                            cx.shadowColor = "orange";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.065 * size, ml * 0.02 * size, ml * 0.01 * size);
                        }
                        break;
                    case 6:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Death Bursts";
                        this.maxPurchases = 3;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Upon killing an enemy, gain +50% attack speed for 0.75 second (+0.75 second per stack).", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[2].purchased >= 2 && totalItemList[3].purchased >= 1;
                        }
                        this.buy = function(){
                            deathBurstDuration += 37.5;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "red";
                            cx.fillRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.04 * size, ml * 0.04 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "cyan";
                            cx.shadowColor = "white";
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.1 * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.1 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.1 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.1 * size, yoffset + ml * size * 0.1);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.1 * size);
                            cx.stroke();
                        }
                        break;
                    case 7:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Shadow Bullets";
                        this.maxPurchases = 3;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Adds a 7% chance to instantly fire a second bullet.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[0].purchased >= 2 && totalItemList[5].purchased >= 1;
                        }
                        this.buy = function(){
                            extraShotChance += 7;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "black";
                            cx.shadowColor = "white";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.025 * size, ml * 0.02 * size, ml * 0.05 * size);
                            cx.fillStyle = "white";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.065 * size, ml * 0.02 * size, ml * 0.01 * size);
                        }
                        break;
                    case 8:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Strengthed Hull";
                        this.maxPurchases = 5;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Increases your max hp by 10.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            health += 10;
                            maxHealth += 10;
                            this.baseCopies += 10;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "darkgray";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                        }
                        break;
                    case 9:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Pre-Emptive Repairs";
                        this.maxPurchases = 3;
                        this.baseCopies = 50;
                        this.description = function(){
                            return ["Restore 4 hp at the start of each wave.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            roundRegen += 4;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                        }
                        break;
                    case 10:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Titanium Exoskeleton";
                        this.maxPurchases = 4;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Reduce contact damage taken by an additive 15%.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[8].purchased >= 2;
                        }
                        this.buy = function(){
                            contactDamageReduction += -0.15;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.002;
                            cx.strokeStyle = "gray";
                            cx.shadowColor = "darkgray";
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.025 * size, ml * 0.025 * size);
                            cx.strokeRect(xoffset + ml * 0.05 * size, yoffset + ml * 0.025 * size, ml * 0.025 * size, ml * 0.025 * size);
                            cx.strokeRect(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.025 * size, ml * 0.025 * size);
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.05 * size, ml * 0.025 * size, ml * 0.025 * size);
                        }
                        break;
                    case 11:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Impact-Powered Repairs";
                        this.maxPurchases = 2;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Upon taking contact damage, regenerate back 25% (+25% per stack) of the base damage over 4 seconds. Taking any damage during this regen effect will either reset or cancel the effect, depending on if it's physical or not.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[10].purchased >= 2;
                        }
                        this.buy = function(){
                            delayedContactHealing += 0.25;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.lineWidth = ml * 0.001;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 0.25, Math.PI * 1.75);
                            cx.stroke();
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.closePath();
                        }
                        break;
                    case 12:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Friction Shielding";
                        this.maxPurchases = 2;
                        this.baseCopies = 100;
                        this.description = function(){
                            return ["Reduces contact damage and increases ramming damage dealt to enemies based on your move speed, provided you are moving.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[8].purchased >= 1 && totalItemList[3].purchased >= 2;
                        }
                        this.buy = function(){
                            speedStatMulti++;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "gray";
                            cx.shadowColor = "gray";
                            cx.lineWidth = ml * 0.002;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.03 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.03 * size);
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.07 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.07 * size);
                            cx.stroke();
                            cx.strokeStyle = "cyan";
                            cx.shadowColor = "cyan";
                            cx.lineWidth = ml * 0.001;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 0.25, Math.PI * 1.75);
                            cx.stroke();
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.closePath();
                        }
                        break;
                    case 13:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Rash Engineering";
                        this.maxPurchases = 2;
                        this.baseCopies = 100;
                        this.description = function(){
                            return ["Reduces the time taken by the delayed healing upon contact damage by 1 second.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[11].purchased >= 1 && totalItemList[10].purchased >= 2 && totalItemList[8].purchased >= 4;
                        }
                        this.buy = function(){
                            DCHtime--;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.fillStyle = "red";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.015 * size);
                            cx.fillRect(xoffset + ml * 0.0425 * size, yoffset + ml * 0.04 * size, ml * 0.015 * size, ml * 0.035 * size);
                        }
                        break;
                    case 14:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Repulsion Shielding";
                        this.maxPurchases = 4;
                        this.baseCopies = 80;
                        this.description = function(){
                            return ["Adds a base 10 damage to ramming and increases overall ramming damage by 10%, additively.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[10].purchased >= 2 && totalItemList[8].purchased >= 3;
                        }
                        this.buy = function(){
                            rammingDamage += 0.1;
                            baseRammingDamage += 10;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "gray";
                            cx.shadowColor = "darkgray";
                            cx.lineWidth = ml * 0.0015;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.035 * size, 0, Math.PI * 2);
                            cx.stroke();
                        }
                        break;
                    case 15:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Impact Reserves";
                        this.maxPurchases = 3;
                        this.baseCopies = 80;
                        this.description = function(){
                            return ["Every enemy you kill through ramming adds 0.5 (+0.5 per stack) to a counter. Taking damage from any non-contact damage source will remove 3 (+1 per stack) from the counter, but it will not go into negatives. At the end of the wave, heal equal to the counter amount.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[9].purchased >= 2 && totalItemList[10].purchased >= 1;
                        }
                        this.buy = function(){
                            rammingGains += 0.5;
                            if(this.purchased == 0){
                                rammingLosses += 3;
                            } else{
                                rammingLosses += 1;
                            }
                            this.baseCopies += 15;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.fillStyle = "gray";
                            cx.shadowColor = "red";
                            cx.fillRect(xoffset + ml * 0.09 * size, yoffset + ml * 0.025 * size, ml * 0.01 * size, ml * 0.05 * size);
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.lineWidth = ml * 0.0015;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.02 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.strokeStyle = "cyan";
                            cx.shadowColor = "cyan";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.closePath();
                        }
                        break;
                    case 16:
                        this.nameColor = "darkgray";
                        this.nameGlowColor = "maroon";
                        this.name = "Agressor Model Overhaul";
                        this.maxPurchases = 1;
                        this.baseCopies = 100;
                        this.boxStyle = 'gold';
                        this.boxGlowStyle = 'gold';
                        this.description = function(){
                            return ["Massively reduces your rate of fire and immunity frames when receiving contact damage. However, increases contact damage resistance by 10%, adds 100% ramming damage, reduces the time delayed contact healing takes by a further 0.5 seconds, and increases your move speed by 5.", "Purchasing an overhaul upgrade will lock you out from purchasing any other."];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[14].purchased >= 2 && totalItemList[10].purchased >= 4 && totalItemList[13].purchased >= 2 && totalItemList[12].purchased >= 1 && totalItemList[17].purchased >= 2 && overhaul == false;
                        }
                        this.buy = function(){
                            overhaul = true;
                            shotDelay = shotDelay * 5;
                            contactDamageReduction += 0.1;
                            rammingDamage++;
                            DCHtime += -0.5;
                            playerSpeed += 5;
                            rammingIframes = 0.1;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "black";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "black";
                            cx.shadowColor = "cyan";
                            cx.lineWidth = ml * 0.0015;
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.005 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.01 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.015 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.02 * size, 0, Math.PI * 2);
                            cx.stroke();
                        }
                        break;
                    case 17:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Rapid Power Diversion";
                        this.maxPurchases = 3;
                        this.baseCopies = 100;
                        this.description = function(){
                            return ["Heal for 0.25 (+0.25 per stack) hp per kill done with ramming damage.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[13].purchased >= 1 && totalItemList[9].purchased >= 1;
                        }
                        this.buy = function(){
                            this.baseCopies += 20;
                            rammingKillSteal += 0.25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.025 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.shadowColor = "lime";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.02 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.shadowColor = "lime";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.015 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.shadowColor = "lime";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.01 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.03 * size, Math.PI * 1.75, Math.PI * 0.25);
                            cx.stroke();
                            cx.closePath();
                        }
                        break;
                    case 18:
                        this.nameColor = "white";
                        this.nameGlowColor = "pink";
                        this.name = "Chained Power Surge";
                        this.maxPurchases = 3;
                        this.baseCopies = 200;
                        this.description = function(){
                            return ["Killing an enemy with ramming damage less than 0.5 seconds after killing one previously increases the effectiveness of rapid power diversion by 50% (+50% per stack).", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[16].purchased >= 1;
                        }
                        this.buy = function(){
                            this.baseCopies += 40;
                            chainRamming += 0.5;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, Math.PI * 0.5, Math.PI * 1.5);
                            cx.stroke();
                            cx.strokeStyle = "cyan";
                            cx.shadowColor = "cyan";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.015 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.fillStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.008 * size, 0, Math.PI * 2);
                            cx.fill();
                        }
                        break;
                    case 19:
                        this.nameColor = "white";
                        this.nameGlowColor = "pink";
                        this.name = "Shielding Flow";
                        this.maxPurchases = 3;
                        this.baseCopies = 200;
                        this.description = function(){
                            return ["Killing an enemy with ramming damage temporarily makes you immune to contact damage for 0.2 (+0.2 per stack) seconds.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[16].purchased >= 1;
                        }
                        this.buy = function(){
                            this.baseCopies += 40;
                            rammingImmunityTime += 0.2;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.045 * size, Math.PI * 0.5, Math.PI * 1.5);
                            cx.stroke();
                            cx.strokeStyle = "cyan";
                            cx.shadowColor = "cyan";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.035 * size, 0, Math.PI * 2);
                            cx.stroke();
                        }
                        break;
                    case 20:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "In-Transit Restoration";
                        this.maxPurchases = 5;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["After not taking damage for 5 seconds, regen 1% (+1% per stack) of your max hp per second.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[21].purchased >= 1 && totalItemList[3].purchased >= 1;
                        }
                        this.buy = function(){
                            combatRegen += 0.01;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.lineWidth = ml * 0.002;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.03 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.03 * size);
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.07 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.07 * size);
                            cx.stroke();
                        }
                        break;
                    case 21:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "On-Site Tuneup";
                        this.maxPurchases = 3;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Upon leveling up, heal for 10 (+8 per stack) hp.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[9].purchased >= 2;
                        }
                        this.buy = function(){
                            if(this.purchased == 0){
                                levelRegen += 10;
                            } else{
                                levelRegen += 8;
                            }
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.01 * size, yoffset + ml * 0.06 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.fillStyle = "rgb(120, 78, 5)";
                            cx.shadowColor = "green";
                            cx.fillRect(xoffset + ml * 0.06 * size, yoffset + ml * 0.075 * size, ml * 0.015 * size, ml * 0.015 * size);
                            cx.fillRect(xoffset + ml * 0.075 * size, yoffset + ml * 0.075 * size, ml * 0.015 * size, ml * 0.015 * size);
                            cx.fillRect(xoffset + ml * 0.07 * size, yoffset + ml * 0.06 * size, ml * 0.015 * size, ml * 0.015 * size);
                        }
                        break;
                    case 22:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Accelerated Cannon";
                        this.maxPurchases = 3;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Upon killing an enemy, fire a bullet that does 25% (+25% per stack) of your base damage at the nearest enemy.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[7].purchased >= 2 && totalItemList[6].purchased >= 1;
                        }
                        this.buy = function(){
                            deathMissleDamage += 0.25;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.04 * size, ml * 0.05 * size, ml * 0.02 * size);
                            cx.fillStyle = "cyan";
                            cx.fillRect(xoffset + ml * 0.065 * size, yoffset + ml * 0.04 * size, ml * 0.01 * size, ml * 0.02 * size);
                            cx.strokeStyle = "cyan";
                            cx.lineWidth = ml * 0.002;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.03 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.03 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.07 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.07 * size, yoffset);
                            cx.stroke();
                        }
                        break;
                    case 23:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Precision Targeting";
                        this.maxPurchases = 5;
                        this.baseCopies = 100;
                        this.description = function(){
                            return ["Projectiles have a 10% (+10% per stack) chance to crit, dealing double damage.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[0].purchased >= 3;
                        }
                        this.buy = function(){
                            critChance += 0.1;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.strokeRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.04 * size, ml * 0.04 * size);
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.1 * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.1 * size);
                            cx.stroke();
                        }
                        break;
                    case 24:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Growing Shot";
                        this.maxPurchases = 4;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Projectiles grow in size and damage as they travel, up to +50% (+50% per stack) of their original damage.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[5].purchased >= 2;
                        }
                        this.buy = function(){
                            maxAccelBonus += 0.5;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "white";
                            cx.fillRect(xoffset + ml * 0.008 * size, yoffset + ml * 0.03 * size, ml * 0.02 * size, ml * 0.02 * size);
                            cx.fillRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.025 * size, ml * 0.025 * size);
                            cx.fillRect(xoffset + ml * 0.06 * size, yoffset + ml * 0.03 * size, ml * 0.03 * size, ml * 0.03 * size);
                        }
                        break;
                    case 25:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Bouncy Bullets";
                        this.maxPurchases = 3;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Projectiles have a 30% (+10% per stack) chance to be bouncy, causing them to bounce off walls 1 (+1 per stack) time(s).", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[5].purchased >= 3 && totalItemList[24].purchased >= 2;
                        }
                        this.buy = function(){
                            if(this.purchased == 0){
                                bounceChance += 0.3;
                            } else{
                                bounceChance += 0.1;
                            }
                            bounceTimes++;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "blue";
                            cx.shadowColor = "white";
                            cx.fillRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.04 * size, ml * 0.04 * size);
                        }
                        break;
                    case 26:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Improved Materials";
                        this.maxPurchases = 5;
                        this.baseCopies = 125;
                        this.description = function(){
                            return ["Your projectiles last 0.2 seconds longer.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[5].purchased >= 4;
                        }
                        this.buy = function(){
                            bulletDuration += 10;
                            this.baseCopies += 20;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "white";
                            cx.fillRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.02 * size, ml * 0.04 * size);
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.05 * size, yoffset + ml * 0.03 * size, ml * 0.02 * size, ml * 0.04 * size);
                        }
                        break;
                    case 27:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Fragmented Bullets";
                        this.maxPurchases = 3;
                        this.baseCopies = 150;
                        this.description = function(){
                            return ["Bullets that hit an enemy split into 1 (+1 per stack) bullet(s) with 30% the damage of the original hit, and travel in a random direction. These fragments cannot create more fragments.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[26].purchased >= 2;
                        }
                        this.buy = function(){
                            fragmentBullets++;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.fillRect(xoffset + ml * 0.01 * size, yoffset + ml * 0.03 * size, ml * 0.02 * size, ml * 0.02 * size);
                            cx.fillRect(xoffset + ml * 0.07 * size, yoffset + ml * 0.03 * size, ml * 0.02 * size, ml * 0.02 * size);
                        }
                        break;
                    case 28:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Resilient Make";
                        this.maxPurchases = 3;
                        this.baseCopies = 150;
                        this.description = function(){
                            return ["Bullets have a 15% (+15% per stack) to be resilient, meaning they will only be destroyed if the enemy they strike does not die. If they do kill an enemy, they will pierce through but lose damage equal to the hp of the enemy remaining when the bullet struck. Resets growing shot bonus.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[26].purchased >= 2 && totalItemList[24].purchased >= 2;
                        }
                        this.buy = function(){
                            pierceChance += 0.15;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "orange";
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.fillStyle = "orange";
                            cx.fillRect(xoffset + ml * 0.015 * size, yoffset + ml * 0.04 * size, ml * 0.02 * size, ml * 0.02 * size);
                            cx.fillRect(xoffset + ml * 0.065 * size, yoffset + ml * 0.04 * size, ml * 0.02 * size, ml * 0.02 * size);
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.065 * size, ml * 0.02 * size, ml * 0.02 * size);
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.015 * size, ml * 0.02 * size, ml * 0.02 * size);
                        }
                        break;
                    case 29:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Elastic Enhancements";
                        this.maxPurchases = 4;
                        this.baseCopies = 200;
                        this.description = function(){
                            return ["Bouncy bullets bounce one more time and all bullets last 0.1 seconds longer.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[25].purchased >= 2;
                        }
                        this.buy = function(){
                            bounceTimes++;
                            bulletDuration += 5;
                            this.baseCopies += 30;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "blue";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.01 * size, ml * 0.02 * size, ml * 0.08 * size);
                        }
                        break;
                    case 30:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Sharpened Fragments";
                        this.maxPurchases = 3;
                        this.baseCopies = 200;
                        this.description = function(){
                            return ["Fragment bullets now deal 40% (+10% per stack) of the damage the original hit dealt.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[27].purchased >= 2;
                        }
                        this.buy = function(){
                            fragmentDamage += 0.1;
                            this.baseCopies += 35;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.strokeStyle = "white";
                            cx.lineWidth = ml/500;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size);
                            cx.lineTo(xoffset + ml * 0.05  * size, yoffset + ml * 0.02 * size);
                            cx.moveTo(xoffset + ml * 0.065 * size, yoffset + ml * 0.035 * size);
                            cx.lineTo(xoffset + ml * 0.05  * size, yoffset + ml * 0.02 * size);
                            cx.stroke();
                        }
                        break;
                    case 31:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Friction Bypass";
                        this.maxPurchases = 4;
                        this.baseCopies = 200;
                        this.description = function(){
                            return ["Resilient bullets lose 12.5% less damage, additively, per stack upon piercing.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[28].purchased >= 2;
                        }
                        this.buy = function(){
                            pierceLoss -= 0.125;
                            this.baseCopies += 35;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.strokeStyle = "gray";
                            cx.lineWidth = ml/500;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.035 * size);
                            cx.lineTo(xoffset + ml * 0.03 * size, yoffset + ml * 0.09 * size);
                            cx.moveTo(xoffset + ml * 0.075 * size, yoffset + ml * 0.035 * size);
                            cx.lineTo(xoffset + ml * 0.07 * size, yoffset + ml * 0.09 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.07 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.09 * size);
                            cx.stroke();
                        }
                        break;
                    case 32:
                        this.nameColor = "blue";
                        this.nameGlowColor = "orange";
                        this.name = "Cannon Model Overhaul";
                        this.maxPurchases = 1;
                        this.baseCopies = 100;
                        this.boxStyle = 'gold';
                        this.boxGlowStyle = 'gold';
                        this.description = function(){
                            return ["Reduces your max hp by 35. In return, increases your chance to fire piercing and bouncing bullets by an additive 20%. Also increases bullet duration by 1.2 seconds", "Purchasing an overhaul upgrade will lock you out from purchasing any other."];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[30].purchased >= 2 && totalItemList[31].purchased >= 2 && totalItemList[29].purchased >= 2 && overhaul == false;
                        }
                        this.buy = function(){
                            maxHealth -= 35;
                            health -= 35;
                            pierceChance += 0.2;
                            bounceChance += 0.2;
                            bulletDuration += 60;
                            overhaul = true;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.shadowColor = "cyan"
                            cx.fillStyle = "black"
                            cx.fillRect(xoffset, yoffset + 0.07 * size * ml, 0.1 * size * ml, 0.02 * size * ml)
                            cx.fillRect(xoffset + 0.01 * size * ml, yoffset, 0.02 * size * ml, 0.07 * size * ml)
                            cx.fillRect(xoffset + 0.07 * size * ml, yoffset, 0.02 * size * ml, 0.07 * size * ml)
                            cx.fillStyle = "orange"
                            cx.shadowColor = "orange"
                            cx.fillRect(xoffset + 0.03 * size * ml, yoffset + 0.01 * size * ml, 0.04 * size * ml, 0.055 * size * ml)
                        }
                        break;
                    case 33:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Miniature Shield Generator";
                        this.maxPurchases = 5;
                        this.baseCopies = 100;
                        this.description = function(){
                            return ["Gain 6 shield. When taking damage, shield is removed before hp. Shield regenerates to full over 3 seconds after not taking damage for 5 seconds, and is fully restored at the end of each round.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[8].purchased >= 1 && totalItemList[1].purchased >= 2;
                        }
                        this.buy = function(){
                            shield += 6
                            maxShield += 6
                            this.baseCopies += 20
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "blue";
                            cx.shadowColor = "blue";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.045 * size, 0, Math.PI * 2);
                            cx.stroke();
                        }
                        break;
                    case 34:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Energized Reactor";
                        this.maxPurchases = 3;
                        this.baseCopies = 150;
                        this.description = function(){
                            return ["While you have shield, gain +15% (+15% per stack) attack speed.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[33].purchased >= 2 && totalItemList[2].purchased >= 1;
                        }
                        this.buy = function(){
                            shieldAttackSpeedBonus += 0.15
                            this.baseCopies += 25
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "blue";
                            cx.shadowColor = "blue";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.045 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.045 * size, 0, Math.PI * 2);
                            cx.stroke();
                        }
                        break;
                    case 35:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Precision Shadow Strike";
                        this.maxPurchases = 3;
                        this.baseCopies = 150;
                        this.description = function(){
                            return ["Landing a critical hit has a 10% (+5% per stack) chance to instantly give you another shadow bullet charge.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[23].purchased >= 3 && totalItemList[7].purchased >= 1;
                        }
                        this.buy = function(){
                            if(this.purchased == 0){
                                critShadowChance += 0.1;
                            } else{
                                critShadowChance += 0.05;
                            }
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.shadowColor = "white";
                            cx.fillStyle = "black";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.025 * size, ml * 0.02 * size, ml * 0.05 * size);
                            cx.fillStyle = "white";
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.065 * size, ml * 0.02 * size, ml * 0.01 * size);
                            cx.strokeStyle = "white";
                            cx.strokeRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.04 * size, ml * 0.04 * size);
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.1 * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.1 * size);
                            cx.stroke();
                        }
                        break;
                    case 36:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Harnessed Impact";
                        this.maxPurchases = 4;
                        this.baseCopies = 150;
                        this.description = function(){
                            return ["If a shot deals 4x or more of your base damage, heal for 0.5 (+0.5 per stack) hp upon impact.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[23].purchased >= 1 && totalItemList[24].purchased >= 2;
                        }
                        this.buy = function(){
                            largeDamageHealing += 0.5;
                            this.baseCopies += 25;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.04 * size, ml * 0.05 * size, ml * 0.02 * size);
                            cx.fillStyle = "gray";
                            cx.shadowColor = "red";
                            cx.fillRect(xoffset + ml * 0.09 * size, yoffset + ml * 0.025 * size, ml * 0.01 * size, ml * 0.05 * size);
                            cx.strokeStyle = "gray";
                            cx.shadowColor = "gray";
                            cx.lineWidth = ml * 0.002;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.04 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.03 * size);
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.06 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.07 * size);
                            cx.stroke();
                        }
                        break;
                    case 37:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Reactive Bullets";
                        this.maxPurchases = 5;
                        this.baseCopies = 180;
                        this.description = function(){
                            return ["Critical hits create a small aoe that lasts for 1 (+0.5 per stack) seconds and deals 100%  of your base damage per second.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[23].purchased >= 3;
                        }
                        this.buy = function(){
                            if (this.purchased == 0){
                                critAoeDuration += 1;
                            } else{
                                critAoeDuration += 0.5;
                            }
                            this.baseCopies += 30;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "gray";
                            cx.shadowColor = "red";
                            cx.fillRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.04 * size, ml * 0.04 * size);
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset, yoffset + ml * 0.04 * size, ml * 0.04 * size, ml * 0.02 * size);
                            cx.lineWidth = ml * 0.0015 * size;
                            cx.strokeStyle = "cyan";
                            cx.beginPath()
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.025 * size, 0, Math.PI * 2)
                            cx.stroke();
                        }
                        break;
                    case 38:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Autonomous Targeting Matrix";
                        this.maxPurchases = 5;
                        this.baseCopies = 180;
                        this.description = function(){
                            return ["Gain 5% crit chance and 15% critical damage.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[36].purchased >= 1 && totalItemList[37].purchased >= 2;
                        }
                        this.buy = function(){
                            critChance += 0.05
                            critDamage += 0.15
                            this.baseCopies += 30;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.strokeStyle = "cyan";
                            cx.shadowColor = "cyan";
                            cx.lineWidth = ml * 0.003 * size;
                            cx.strokeRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.03 * size, ml * 0.04 * size, ml * 0.04 * size);
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.1 * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.1 * size);
                            cx.stroke();
                            cx.strokeStyle = 'red';
                            cx.shadowColor = 'red';
                            cx.strokeRect(xoffset + ml * 0.02 * size, yoffset + ml * 0.03 * size, ml * 0.06 * size, ml * 0.04 * size);
                            cx.strokeRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.02 * size, ml * 0.04 * size, ml * 0.06 * size);
                        }
                        break;
                    case 39:
                        this.nameColor = "white";
                        this.nameGlowColor = "cyan";
                        this.name = "Desperation Overcharge";
                        this.maxPurchases = 3;
                        this.baseCopies = 180;
                        this.description = function(){
                            return ["When your shield breaks, spawn an aoe around you that deals 150% (+150% per stack) of your base damage and lasts for 5 seconds.", "Max Stacks: " + this.maxPurchases, 'Purchased: ' + this.purchased];
                        }
                        this.copies = function(){
                            return this.baseCopies;
                        }
                        this.requirements = function(){
                            return totalItemList[37].purchased >= 1 && totalItemList[34].purchased >= 2;
                        }
                        this.buy = function(){
                            shieldBreakAoeDamage += 1.5
                            this.baseCopies += 30;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = "blue";
                            cx.shadowColor = "blue";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.045 * size, 0, Math.PI * 2);
                            cx.stroke();
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.arc(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size, ml * 0.04 * size, 0, Math.PI * 2);
                            cx.stroke();
                        }
                        break;
                    case 40:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Elemental Powered Gatling";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Doubles your attack speed, but halves all damage you deal, regardless of type."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            shotDelay *= 0.5;
                            curseChance *= curseChanceLoss;
                            playerDamageMulti *= 0.5;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.strokeStyle = "white";
                            cx.shadowColor = "white";
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.01 * size, ml * 0.05 * size);
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.strokeRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.03 * size, ml * 0.05 * size, ml * 0.01 * size);
                            cx.strokeStyle = "blue";
                            cx.shadowColor = "blue";
                            cx.strokeRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.045 * size, ml * 0.05 * size, ml * 0.01 * size);
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "lime";
                            cx.strokeRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.06 * size, ml * 0.05 * size, ml * 0.01 * size);
                        }
                        break;
                    case 41:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Cursed Idol";
                        this.maxPurchases = 1;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.baseCopies = Infinity;
                        this.description = function(){
                            return ["Forbidden Upgrade", "Doubles your xp gain, but you shall anger the deities who control the knowledge."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            multiplicativeXpGain *= 2;
                            curseChance *= curseChanceLoss;
                            skillIDCounter++;
                            aoes.push(new circlecomponent(0, 0, curseCircleSize, ml/1000, 'lime', 'lime'));
                            areass.push(new areasSideStats(0, 0, 0, 'Curse', false, false));
                            aoeTrackerID.push(skillIDCounter);
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.strokeStyle = "lime";
                            cx.shadowColor = "blue";
                            cx.beginPath();
                            cx.arc(xoffset + ml * size * 0.05, yoffset + ml * 0.04 * size, 0.03 * size * ml, Math.PI, Math.PI * 2);
                            cx.moveTo(xoffset + ml * size * 0.02, yoffset + ml * 0.04 * size);
                            cx.lineTo(xoffset + ml * size * 0.05, yoffset + ml * 0.09 * size);
                            cx.lineTo(xoffset + ml * size * 0.08, yoffset + ml * 0.04 * size);
                            cx.stroke()
                            cx.fillStyle = 'lime';
                            cx.shadowColor = 'lime';
                            cx.beginPath()
                            cx.moveTo(xoffset + ml * size * 0.04, yoffset + ml * 0.04 * size);
                            cx.arc(xoffset + ml * size * 0.04, yoffset + ml * 0.04 * size, 0.008 * size * ml, 0, Math.PI * 2);
                            cx.moveTo(xoffset + ml * size * 0.06, yoffset + ml * 0.04 * size);
                            cx.arc(xoffset + ml * size * 0.06, yoffset + ml * 0.04 * size, 0.008 * size * ml, 0, Math.PI * 2);
                            cx.fill();
                        }
                        break;
                    case 42:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Glass Mainframe";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Doubles all damage you deal and receive."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            damageReduction *= 2;
                            curseChance *= curseChanceLoss;
                            playerDamageMulti *= 2;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.strokeStyle = "white";
                            cx.shadowColor = "white";
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                        }
                        break;
                    case 43:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Hungering Bullets";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "All bullets are bouncy. Gain 4 bounces and bullets last 1.5 second longer. However, your own bullets can now hit you. Self damage dealt by bullets is affected by the global enemy damage scaling."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            selfBulletDamage = true;
                            bounceChance = 1;
                            bounceTimes += 4;
                            bulletDuration += 75;
                            curseChance *= curseChanceLoss;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.lineWidth = ml * 0.001;
                            cx.strokeStyle = "red";
                            cx.shadowColor = "red";
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size);
                            let teeth = 8;
                            for(let i = 1; i < teeth + 1; i++){
                                if(i % 2 != 0){
                                    cx.lineTo(xoffset + ml * (0.025 + 0.05/teeth * i) * size, yoffset + ml * 0.075 * size);
                                } else{
                                    cx.lineTo(xoffset + ml * (0.025 + 0.05/teeth * i)  * size, yoffset + ml * 0.025 * size);
                                }
                            }
                            cx.stroke()
                            cx.strokeStyle = "blue";
                            cx.shadowColor = "blue";
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                        }
                        break;
                    case 44:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Goliath Form";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Increase your damage and size by 1.5 times."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            playerSize *= 1.5;
                            character.width = playerSize;
                            character.height = playerSize;
                            playerDamageMulti *= 1.5;
                            curseChance *= curseChanceLoss;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.015 * size, yoffset + ml * 0.015 * size, ml * 0.07 * size, ml * 0.07 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = 'red';
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);                            cx.shadowColor = 'red';
                            cx.strokeRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                        }
                        break;
                    case 45:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Ant Form";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Reduce your size by 33% but reduce your damage by half."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            playerSize /= 1.5;
                            character.width = playerSize;
                            character.height = playerSize;
                            playerDamageMulti *= 0.5;
                            curseChance *= curseChanceLoss;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "white";
                            cx.shadowColor = "cyan";
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.lineWidth = ml * 0.0015;
                            cx.strokeStyle = 'red';
                            cx.strokeRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);                            cx.shadowColor = 'red';
                            cx.strokeRect(xoffset + ml * 0.015 * size, yoffset + ml * 0.015 * size, ml * 0.07 * size, ml * 0.07 * size);
                        }
                        break;
                    case 46:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Unstoppable Virus";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Reduces the rate at which enemies grow stronger per wave, but increase the rate at which the xp requirement for levels grows. Only effects waves and levels after this upgrade."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            xpGrowth += 0.04;
                            enemyHpScaling -= 0.04;
                            enemyDamageScaling -= 0.01;
                            curseChance *= curseChanceLoss;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = "red";
                            cx.shadowColor = "red";
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size, ml * 0.03 * size, ml * 0.03 * size);
                            cx.strokeStyle = "black";
                            cx.lineWidth = ml/500;
                            cx.beginPath();
                            cx.moveTo(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size);
                            cx.lineTo(xoffset + ml * 0.01  * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.035 * size, yoffset + ml * 0.065 * size);
                            cx.lineTo(xoffset + ml * 0.01  * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.035 * size, yoffset + ml * 0.035 * size);
                            cx.lineTo(xoffset + ml * 0.02  * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.035 * size, yoffset + ml * 0.065 * size);
                            cx.lineTo(xoffset + ml * 0.02  * size, yoffset + ml * 0.05 * size);
                            cx.moveTo(xoffset + ml * 0.05 * size, yoffset + ml * 0.05 * size);
                            cx.lineTo(xoffset + ml * 0.01  * size, yoffset + ml * 0.05 * size);
                            cx.stroke();
                        }
                        break;
                    case 47:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Doom Module";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Gain 5 projectiles. Increase your shot spread by 15 degrees. Reduce your bullet lifetime by 66%. Reduce your damage by 33%."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            playerProjectiles += 5;
                            bulletDurationMulti /= 3;
                            shotSpread += 15;
                            playerDamageMulti /= 1.5;
                            curseChance *= curseChanceLoss;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = 'gray';
                            cx.shadowColor = 'cyan';
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.05 * size);
                            cx.fillStyle = 'green';
                            cx.fillRect(xoffset + ml * 0.025 * size, yoffset + ml * 0.025 * size, ml * 0.05 * size, ml * 0.02 * size);
                            cx.fillStyle = 'red';
                            cx.fillRect(xoffset + ml * 0.03 * size, yoffset + ml * 0.035 * size, ml * 0.015 * size, ml * 0.015 * size);
                            cx.fillRect(xoffset + ml * 0.055 * size, yoffset + ml * 0.035 * size, ml * 0.015 * size, ml * 0.015 * size);
                        }
                        break;
                    case 48:
                        this.nameColor = "white";
                        this.nameGlowColor = "red";
                        this.name = "Parasite Module";
                        this.maxPurchases = 1;
                        this.baseCopies = Infinity;
                        this.boxStyle = 'red';
                        this.boxGlowStyle = 'red';
                        this.description = function(){
                            return ["Forbidden Upgrade", "Your health constantly degrades at a rate of 2% of your max hp per second. Hitting enemies now heals you for 2 health."];
                        }
                        this.copies = function(){
                            if(Math.random() < curseChance){
                                return this.baseCopies;
                            } else{
                                return 0;
                            }
                        }
                        this.requirements = function(){
                            return true;
                        }
                        this.buy = function(){
                            globalLifeSteal += 2;
                            healthDegrade += 0.02;
                            curseChance *= curseChanceLoss;
                        }
                        this.icon = function(xoffset, yoffset, size){
                            cx.fillStyle = 'white';
                            cx.shadowColor = 'cyan';
                            cx.fillRect(xoffset, yoffset + ml * 0.075 * size, ml * 0.1 * size, ml * 0.025 * size);
                            cx.fillStyle = 'pink';
                            cx.shadowColor = 'red';
                            cx.fillRect(xoffset + ml * 0.04 * size, yoffset + ml * 0.015 * size, ml * 0.02 * size, ml * 0.05 * size);
                            cx.fillRect(xoffset + ml * 0.035 * size, yoffset + ml * 0.065 * size, ml * 0.01 * size, ml * 0.02 * size);
                            cx.fillRect(xoffset + ml * 0.055 * size, yoffset + ml * 0.065 * size, ml * 0.01 * size, ml * 0.02 * size);
                        }
                        break;
                    default:
                        preGameCycler = true;
                        break;
                }
            }
        }
        class enemyTypeHolder{
            constructor(type){
                this.trackerID = type;
                //notes: ai requirements
                //moveai = follow: follow distance
                //shotai != undefined: shotdelay, projectile size, projectile speed, projectile properties, projectiledamage, burst, burstdelay, iterations, iterationdelay, bulletduration, shootmove
                //skill != undefined: skilldelay, skillduration, skillmove (true/false) 
                //skill laser: laserspeed, laserlength (1500 = max, reaches regardless), skillOrigin, lasersize, laserdamage, lasertype
                //lasertype == sweep: sweep precision (lower = better)
                //contact == true: selfContactDamage
                //lasertype == predict: predictprecision (how far in the future, in ms, that the laser will aim)
                //skill == aoe: aoesize, aoedamage (multiplier), aoehealing (flat), damageconsume, healconsume
                this.projectileProperties = new bulletProperties(false, false, 0, false, false);
                switch(type){
                    case 0:
                    case "Basic":
                        this.color = "gray";
                        this.glowcolor = "red";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.moveai = "Converge";
                        this.shotai = undefined;
                        this.skill = undefined;
                        this.contact = true;
                        this.selfContactDamage = 1;
                        this.size = 25;
                        this.speed = 4;
                        this.damage = 3;
                        this.hp = 8;
                        this.minWave = 1;
                        this.maxWave = 10;
                        this.cost = 10;
                        this.reward = 2;
                        this.weight = 5000;
                        break;
                    case 1:
                    case "Shooter":
                        this.color = "lightgrey";
                        this.glowcolor = "orange";
                        this.moveai = "Follow";
                        this.shotai = "Basic";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.shootMove = true;
                        this.skill = undefined;
                        this.contact = true;
                        this.selfContactDamage = 0;
                        this.size = 30;
                        this.speed = 3;
                        this.damage = 2;
                        this.burst = 1;
                        this.projectileDuration = 150;
                        this.burstDelay = 0;
                        this.shotIterations = 1;
                        this.iterationsDelay = 0;
                        this.hp = 12;
                        this.minWave = 2;
                        this.maxWave = 15;
                        this.cost = 20;
                        this.reward = 3;
                        this.weight = 3000;
                        this.shotDelay = 2500;
                        this.projectileSize = 10;
                        this.projectileSpeed = 10;
                        this.projectileDamage = 1;
                        this.followDistance = 0.3;
                        break;
                    case 5:
                    case "Shotgun":
                        this.color = "white";
                        this.glowcolor = "red";
                        this.moveai = "Follow";
                        this.shotai = "DirectedAngle";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.shootMove = true;
                        this.skill = undefined;
                        this.contact = true;
                        this.cycleCount = 5;
                        this.angleOffset = 30;
                        this.selfContactDamage = 0;
                        this.size = 30;
                        this.speed = 3;
                        this.damage = 2;
                        this.burst = 5;
                        this.projectileDuration = 200;
                        this.burstDelay = 0;
                        this.shotIterations = 1;
                        this.iterationsDelay = 0;
                        this.hp = 8;
                        this.minWave = 4;
                        this.maxWave = Infinity;
                        this.cost = 20;
                        this.reward = 4;
                        this.weight = 3000;
                        this.shotDelay = 4000;
                        this.projectileSize = 10;
                        this.projectileSpeed = 4;
                        this.projectileDamage = 1;
                        this.followDistance = 0.4;
                        break;
                    case 3:
                    case "Flayer":
                        this.color = "darkorchid";
                        this.glowcolor = "purple";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.shootMove = false;
                        this.moveai = "Follow";
                        this.shotai = "Basic";
                        this.skill = undefined;
                        this.contact = true;
                        this.selfContactDamage = 0;
                        this.projectileDuration = 1000;
                        this.burst = 2;
                        this.burstDelay = 200;
                        this.shotIterations = 1;
                        this.iterationsDelay = 500;
                        this.size = 25;
                        this.speed = 3;
                        this.damage = 4;
                        this.hp = 16;
                        this.minWave = 8;
                        this.maxWave = Infinity;
                        this.cost = 25;
                        this.reward = 4;
                        this.weight = 2000;
                        this.shotDelay = 3500;
                        this.projectileSize = 10;
                        this.projectileSpeed = 3;
                        this.projectileDamage = 1;
                        this.followDistance = 0.45;
                        this.projectileProperties = new bulletProperties(true, false, 0, false, false);
                        break;
                    case 2:
                    case "Mite":
                        this.color = "gray";
                        this.glowcolor = "gray";
                        this.moveai = "Converge";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.shotai = undefined;
                        this.skill = undefined;
                        this.contact = true;
                        this.selfContactDamage = 1;
                        this.size = 15;
                        this.speed = 5;
                        this.damage = 3;
                        this.hp = 8;
                        this.minWave = 10;
                        this.maxWave = Infinity;
                        this.cost = 10;
                        this.reward = 5;
                        this.weight = 2500;
                        break;
                    case 6:
                    case "Hunter":
                        this.color = "darkgreen";
                        this.glowcolor = "orange";
                        this.moveai = "Follow";
                        this.shotai = "Predictive";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.shootMove = false;
                        this.skill = undefined;
                        this.contact = true;
                        this.selfContactDamage = 0;
                        this.size = 30;
                        this.speed = 5;
                        this.damage = 4;
                        this.burst = 3;
                        this.projectileDuration = 150;
                        this.burstDelay = 300;
                        this.shotIterations = 1;
                        this.iterationsDelay = 500;
                        this.hp = 12;
                        this.minWave = 15;
                        this.maxWave = Infinity;
                        this.cost = 20;
                        this.reward = 5;
                        this.weight = 3000;
                        this.shotDelay = 2500;
                        this.projectileSize = 10;
                        this.projectileSpeed = 8;
                        this.projectileDamage = 1;
                        this.followDistance = 0.35;
                        break;
                    case 4:
                    case "Tester":
                        this.color = "gray";
                        this.glowcolor = "darkslateblue";
                        this.effectsColor = "red";
                        this.effectsGlowColor = "red";
                        this.moveai = "Follow";
                        this.shotai = 'DirectedAngle';
                        this.skill = undefined;
                        this.contact = true;
                        this.selfContactDamage = 0;
                        this.size = 30;
                        this.speed = 4;
                        this.damage = 5;
                        this.hp = 15;
                        this.minWave = 1;
                        this.shotMinAngle = 0;
                        this.shotMaxAngle = 360;
                        this.angleOffset = 180;
                        this.cycleCount = 360;
                        this.projectileDuration = 500;
                        this.burstChange = true;
                        this.maxWave = Infinity;
                        if(waveActive == false){
                            this.cost = (directorCredits + directorCreditMulti);
                        } else{
                            this.cost = directorCredits; 
                        }
                        this.reward = Infinity;
                        this.weight = 0;
                        this.shotDelay = 1000;
                        this.projectileSize = 10;
                        this.projectileSpeed = 10;
                        this.followDistance = 0.1;
                        this.burst = 360;
                        this.burstDelay = 0;
                        this.shotIterations = 1;
                        this.iterationsDelay = 0;
                        this.projectileDamage = 0;
                        this.skillDelay = 200;
                        this.skillDuration = 2000;
                        this.skillMove = false;
                        this.laserSpeed = 5;
                        this.laserLength = 150;
                        this.laserSize = 1;
                        this.laserDamage = 0.01;
                        this.skillOrigin = "TrueRandom";
                        this.laserType = "Sweep";
                        this.predictPrecision = 500;
                        this.sweepPrecision = 45;
                        this.aoeSize = 1000;
                        this.aoeWidth = 1;
                        this.aoeDamage = 0.25;
                        this.aoeHealing = 500;
                        this.damageConsume = false;
                        this.healConsume = true;
                        break;
                    default:
                        preGameCycler = true;
                        break;
                }
            }
        }
        function begin(){
            character = new squarecomponent(playerSize, playerSize, c.width/2, c.height/2, "white", "cyan");
            playerBuffs = new playerBuffStats();
            let i = 0;
            while(preGameCycler == false){
                enemyStatBlock.push(new enemyTypeHolder(i));
                i++;
            }
            i = 0;
            preGameCycler = false;
            while(preGameCycler == false){
                totalItemList.push(new itemHolder(i));
                i++
            }
            totalItemList.splice(totalItemList.length - 1, 1);
            enemyStatBlock.splice(enemyStatBlock.length - 1, 1);
            itemRoll();
            minCostCalc();
        }
        begin();
        function minCostCalc(){
            minCost = Infinity;
            availableEnemies.length = 0;
            totalWeight = 0;
            for(let i = 0; i < enemyStatBlock.length; i++){
                if(wave < enemyStatBlock[i].maxWave && wave >= enemyStatBlock[i].minWave){
                    totalWeight += enemyStatBlock[i].weight;
                    availableEnemies.push(enemyStatBlock[i])
                    if(enemyStatBlock[i].cost < minCost){
                        minCost = enemyStatBlock[i].cost;
                    }
                }
            }
        }
        function itemRoll(){
            availableItemList.length = 0;
            offeredItems.length = 0;
            let totalWeight = 0
            for(let i = 0; i < totalItemList.length; i++){
                if(totalItemList[i].requirements() && totalItemList[i].purchased < totalItemList[i].maxPurchases && totalItemList[i].copies() > 0){
                    availableItemList.push(totalItemList[i]);
                    totalWeight += totalItemList[i].copies()
                }
            }
            for(let i = 0; i < 4; i++){
                let choice = randomInt(0, totalWeight);
                let choiceTracker = 0;
                for(let t = 0; t < availableItemList.length; t++){
                    if(choice > choiceTracker && choice <= choiceTracker + availableItemList[t].baseCopies){
                        offeredItems.push(availableItemList[t]);
                        availableItemList.splice(t, 1);
                        totalWeight = 0;
                        for(let g = 0; g < availableItemList.length; g++){
                            totalWeight += availableItemList[g].baseCopies;
                        }
                        break;
                    }
                    choiceTracker += availableItemList[t].copies();
                }
            }
        }
        function resize(){
            let tempX = c.width/character.x;
            let tempY = c.height/character.y;
            let tempEnemyX = [];
            let tempEnemyY = [];
            let tempBulletX = [];
            let tempBulletY = [];
            let tempLaserStartY = [];
            let tempLaserStartX = [];
            let tempLaserEndX = [];
            let tempLaserEndY = [];
            let tempAOEX = [];
            let tempAOEY = [];
            for(let i = 0; i < enemies.length; i++){
                tempEnemyX.push(c.width/enemies[i].x);
                tempEnemyY.push(c.height/enemies[i].y);
            }
            for(let i = 0; i < bullets.length; i++){
                tempBulletX.push(c.width/bullets[i].x);
                tempBulletY.push(c.height/bullets[i].y);
            }
            for(let i = 0; i < lasers.length; i++){
                tempLaserStartX.push(c.width/lasers[i].startx);
                tempLaserStartY.push(c.height/lasers[i].starty);
                tempLaserEndX.push(c.width/lasers[i].endx);
                tempLaserEndY.push(c.height/lasers[i].endy);
            }
            for(let i = 0; i < aoes.length; i++){
                tempAOEX.push(c.width/aoes[i].x);
                tempAOEY.push(c.height/aoes[i].y);
            }
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            ml = (c.height + c.width)/2;
            mlhr = Math.floor(c.height/(ml/40)) - 1;
            for(let i = 0; i < enemies.length; i++){
                enemies[i].x = c.width/tempEnemyX[i];
                enemies[i].y = c.height/tempEnemyY[i];
            }
            for(let i = 0; i < bullets.length; i++){
                bullets[i].x = c.width/tempBulletX[i];
                bullets[i].y = c.height/tempBulletY[i];
            }
            for(let i = 0; i < lasers.length; i++){
                lasers[i].startx = c.width/tempLaserStartX[i];
                lasers[i].endx = c.width/tempLaserEndX[i];
                lasers[i].starty = c.height/tempLaserStartY[i];
                lasers[i].endy = c.height/tempLaserEndY[i];
            }
            for(let i = 0; i < aoes.length; i++){
                aoes[i].x = c.width/tempAOEX[i];
                aoes[i].y = c.height/tempAOEY[i];
            }
            character.x = c.width/tempX;
            character.y = c.height/tempY;
            render();
        }
        resize();
        var gameRunner = setInterval(function generalUpdate(){
            if(pause == false){
                if(health <= 0){
                    gameOver = true;
                    health = 0;
                    window.clearInterval(gameRunner)
                    render();
                } else{
                    health -= maxHealth * healthDegrade/50;
                }
                killTime++;
                damageTime++;
                if(damageTime >= regenDelay * 50 && waveActive == true){
                    heal(combatRegen * maxHealth * 0.02);
                }
                if(damageTime >= shieldRegenDelay * 50){
                    shieldHeal(maxShield/(shieldRegenTime * 50))
                }
                if(playerXDirect == 0 || playerYDirect == 0){
                    moving = false;
                    movingRamMulti = 1;
                    movingContactReduction = 1;
                } else{
                    moving = true;
                    movingRamMulti = 1 + 0.035 * playerSpeed * speedStatMulti;
                    movingContactReduction = 1 + 0.008 * playerSpeed * speedStatMulti;
                }
                if(character.x > 0 && playerXDirect == -1 || character.x < c.width && playerXDirect == 1){
                    character.x += ml/1000 * playerSpeed * playerXDirect;
                }
                if(character.y > 0 && playerYDirect == -1 || character.y < c.height && playerYDirect == 1){
                    character.y += ml/1000 * playerSpeed * playerYDirect;
                }
                playerBuffs.deathBurst--;
                if(currentDCH > 0){
                    currentDCH += -storedDCH/(DCHtime * 50);
                    heal(storedDCH/(DCHtime * 50));
                }
                for(let i = 0; i < enemies.length; i++){
                    ess[i].healthBarCounter--;
                    ai(enemies[i], i);
                    if(squareHitDetector(character.x, character.y, ml/2000 * character.width, ml/2000 * character.height, enemies[i].x, enemies[i].y, ml/2000 * enemies[i].width, ml/2000 * enemies[i].height) == true && invulnerable == false && enemyStatBlock[ess[i].type].contact == true){
                        damagePlayer(enemyStatBlock[ess[i].type].damage, "Contact");
                        ess[i].hp += -(enemyStatBlock[ess[i].type].selfContactDamage * enemyStatBlock[ess[i].type].hp * globalEnemyHP + baseRammingDamage) * rammingDamage * movingRamMulti * playerDamageMulti * additivePlayerDamageMulti;
                        if(ess[i].hp <= 0){
                            storedRammingHP += rammingGains;
                            if(killTime < chainRammingTime * 50){
                                heal(rammingKillSteal * chainRamming)
                            } else{
                                heal(rammingKillSteal)
                            }
                        }
                        heal(globalLifeSteal);
                        killChecker(i, "Ramming");
                        break;
                    }
                }
                if(shotAvailable == true && shooting == true || shotAvailable == true && autofire == true){
                    shotCycler();
                    let tempAimer = new aimer(character.x, character.y, mouseX, mouseY);
                    for(let i = 0; i < playerProjectiles; i++){
                        playerShoot(tempAimer.x, tempAimer.y, 1);
                    }
                }
                for(let i = 0; i < lasers.length; i++){
                    if(lineHitDetector(lasers[i].startx, lasers[i].endx, lasers[i].starty, lasers[i].endy, lss[i].xdirect, lss[i].ydirect, lasers[i].size, character.x, character.y, ml/2000 * playerSize) == true){
                        let statCaller = enemyStatBlock[ess[enemyTrackerID.indexOf(lss[i].eoti)].type];
                        damagePlayer(statCaller.damage * statCaller.laserDamage, "DOT");
                    }
                    let offsetPosX = lasers[i].startx;
                    let offsetPosY = lasers[i].starty;
                    let enemyOfOrigin = enemyStatBlock[ess[enemyTrackerID.indexOf(lss[i].eoti)].type];
                    switch(lss[i].type){
                        case "Dynamic":
                            offsetPosY = enemies[enemyTrackerID.indexOf(lss[i].eoti)].y;
                            offsetPosX = enemies[enemyTrackerID.indexOf(lss[i].eoti)].x;
                            lasers[i].startx = offsetPosX;
                            lasers[i].starty = offsetPosY;
                            break;
                        case "Center":
                            offsetPosY = c.height/2;
                            offsetPosX = c.width/2;
                            lasers[i].startx = offsetPosX;
                            lasers[i].starty = offsetPosY;
                            break;
                    }
                    lasers[i].endx = lss[i].xdirect * lss[i].longness * ml/1000 + offsetPosX;
                    lasers[i].endy = lss[i].ydirect * lss[i].longness * ml/1000 + offsetPosY;
                    switch(lss[i].changetype){
                        case "Sweep":
                            if(lss[i].angle * 180/Math.PI >= lss[i].originalAngle * 180/Math.PI + enemyOfOrigin.sweepPrecision * 2){
                                laserDestroy(i);   
                                continue; 
                            }
                        case "Spin":
                            lss[i].angle += 0.01 * enemyOfOrigin.laserSpeed;
                            lss[i].xdirect = Math.sin(lss[i].angle);
                            lss[i].ydirect = Math.cos(lss[i].angle);
                            break;
                    }
                }
                aoerunner: for(let i = 0; i < aoes.length; i++){
                    if (areass[i].eoti == 'Player'){
                        for(let  t = 0; t < enemies.length; t++){
                            if(circleSquareHitDetector(enemies[t].x, enemies[t].y, enemies[t].width * ml/1000, enemies[t].height * ml/1000, aoes[i].x, aoes[i].y, aoes[i].r * ml/1000)){
                                ess[t].hp -= areass[i].damage * playerDamageMulti * additivePlayerDamageMulti;
                                killChecker(t, "DOT");
                                if(areass[i].damageconsume == true){
                                    aoeDestroy(i);
                                    continue aoerunner;
                                }
                            }
                        }
                    } else{
                        if(circleSquareHitDetector(character.x, character.y, ml/1000 * character.width, ml/1000 * character.height, aoes[i].x, aoes[i].y, aoes[i].r * ml/1000)){
                            if (areass[i].eoti == 'Curse'){
                                damagePlayer(maxHealth, undefined);
                            } else{
                                damagePlayer(areass[i].damage, "DOT");
                            }
                            if(areass[i].damageconsume == true){
                                aoeDestroy(i);
                                continue aoerunner;
                            }
                        }
                        for(let t = 0; t < enemies.length; t++){
                            if(distanceCalc(aoes[i].x, aoes[i].y, enemies[t].x, enemies[t].y) - ml/enemies[t].width/2 < ml/1000 * aoes[i].r && ess[t].hp != enemyStatBlock[ess[t].type].hp){
                                if(ess[t].hp + areass[i].healing >= enemyStatBlock[ess[t].type].hp){
                                    ess[t].hp = enemyStatBlock[ess[t].type].hp;
                                    ess[t].healthBarCounter = 110;
                                    if(areass[i].healconsume == true){
                                        aoeDestroy(i);
                                        continue aoerunner;
                                    }
                                } else{
                                    ess[t].hp += areass[i].healing;
                                    ess[t].healthBarCounter = 100;
                                    if(areass[i].healconsume == true){
                                        aoeDestroy(i);
                                        continue aoerunner;
                                    }
                                }
                            }
                        }
                        if (areass[i].eoti == "Curse"){
                            let tempAimer = new aimer(aoes[i].x, aoes[i].y, character.x, character.y);
                            aoes[i].x += tempAimer.x * curseCircleSpeed * ml/1000 * playerSpeed;
                            aoes[i].y += tempAimer.y * curseCircleSpeed * ml/1000 * playerSpeed;
                        } else{
                            let statCaller = enemyStatBlock[ess[enemyTrackerID.indexOf(areass[i].eoti)].type];
                            switch(statCaller.skillOrigin){
                                case "Dynamic":
                                    aoes[i].x = enemies[enemyTrackerID.indexOf(areass[i].eoti)].x;
                                    aoes[i].y = enemies[enemyTrackerID.indexOf(areass[i].eoti)].y;
                                    break;
                            }
                        }
                    }
                }
                markedBullets = [];
                bullethandler: for(let i = 0; i < bullets.length; i++){
                    bss[i].duration--;
                    if(bss[i].duration <= 0){
                        markedBullets.push(bulletTrackerID[i])
                        continue;
                    }
                    if(bss[i].owner == "Player"){
                        bullets[i].x += bulletSpeed * ml/1000 * bss[i].xmom;
                        bullets[i].y += bulletSpeed * ml/1000 * bss[i].ymom;
                        if(bss[i].originalDamage * maxAccelBonus > bss[i].damage){
                            bss[i].damage += bss[i].originalDamage/1500 * bulletSpeed * maxAccelBonus;
                            bullets[i].width += 0.5;
                            bullets[i].height += 0.5;
                        }
                        let markedInteractions = [];
                        for(let t = 0; t < bss[i].interacting.length; t++){
                            let enemyID = enemyTrackerID.indexOf(bss[i].interacting[t]);
                            if(enemyID == -1 || squareHitDetector(enemies[enemyID].x, enemies[enemyID].y, ml/2000 * enemies[enemyID].width, ml/2000 * enemies[enemyID].height, bullets[i].x, bullets[i].y, ml/2000 * bullets[i].width, ml/2000 * bullets[i].height) == false){
                                markedInteractions.push(bss[i].interacting[t]);                         
                            }
                        }
                        for (let t = 0; t < markedInteractions.length; t++){
                            bss[i].interacting.splice(bss[i].interacting.indexOf(markedInteractions[t]));
                        }
                        let totalDamage;
                        for(let t = 0; t < enemies.length; t++){
                            if(squareHitDetector(enemies[t].x, enemies[t].y, ml/2000 * enemies[t].width, ml/2000 * enemies[t].height, bullets[i].x, bullets[i].y, ml/2000 * bullets[i].width, ml/2000 * bullets[i].height) && bss[i].interacting.indexOf(enemyTrackerID[t]) === -1){
                                totalDamage = bss[i].damage * playerDamageMulti * additivePlayerDamageMulti;
                                if(Math.random() < critChance){
                                    totalDamage *= critDamage;
                                    onCritEffects(bullets[i].x, bullets[i].y)
                                }
                                let previousHP = ess[t].hp
                                ess[t].hp -= totalDamage;
                                bss[i].interacting.push(enemyTrackerID[t]);
                                if(bullProperties[i].piercing){
                                    bss[i].damage -= previousHP * pierceLoss;
                                    bss[i].originalDamage = bss[i].damage;
                                    bullets[i].width = bullets[i].originalWidth;
                                    bullets[i].height = bullets[i].originalHeight;
                                }
                                onHitEffects(totalDamage, t, i);
                                killChecker(t, "Projectile");
                                if(bullProperties[i].piercing == false || bss[i].damage <= 0){
                                    markedBullets.push(bulletTrackerID[i]);
                                }
                                continue bullethandler;
                            }
                        }
                        sideHandler(i, bullets[i].width);
                    }
                    if(bss[i].owner == 'Enemy' || selfBulletDamage == true){
                        bullets[i].x += bss[i].speed * ml/1000 * bss[i].xmom;
                        bullets[i].y += bss[i].speed * ml/1000 * bss[i].ymom;
                        if(squareHitDetector(character.x, character.y, ml/2000 * character.width, ml/2000 * character.height, bullets[i].x, bullets[i].y, ml/2000 * bullets[i].width, ml/2000 * bullets[i].height) == true && invulnerable == false){
                            damagePlayer(bss[i].damage, "Projectile");
                            markedBullets.push(bulletTrackerID[i]);
                            continue;
                        }
                        sideHandler(i, bullets[i].width);
                    }
                }
                for(let i = 0; i < markedBullets.length; i++){
                    bulletDestroy(bulletTrackerID.indexOf(markedBullets[i]));
                }
                waveDelayCounter++;
            }
            render();
        }, 20)
        function circleSquareHitDetector(sx, sy, sw, sh, cx, cy, cr){
            for(let i = sy - sh; i < sy + sh; i++){
                if(distanceCalc(sx - sw, i, cx, cy) <= cr || distanceCalc(sx + sw, i, cx, cy) <= cr){
                    return true;
                }
            }
            for(let i = sx - sw; i < sx + sw; i++){
                if(distanceCalc(i, sy - sh, cx, cy) <= cr || distanceCalc(i, sy + sh, cx, cy) <= cr){
                    return true;
                }
            }
            if(distanceCalc(sx, sy, cx, cy) <= cr + (sw + sh)/2){
                return true;
            }
            return false;
        }
        function squareHitDetector(x1, y1, w1, h1, x2, y2, w2, h2){
            return x1 + w1 > x2 - w2 && x1 - w1 < x2 + w2 & y1 + h1 > y2 - w2 && y1 - h1 < y2 + w2;
        }
        function lineHitDetector(x1, x2, y1, y2, xdirect, ydirect, size, targetx, targety, targetsize){
            let expectedYMulti = Math.abs(targetx - x1)/Math.abs(xdirect) * ydirect;
            let maxSide = Math.max(x1, x2);
            let minSide = Math.min(x1, x2);
            let maxSide2 = Math.max(y1, y2);
            let minSide2 = Math.min(y1, y2);
            return targetx + targetsize + size * Math.abs(ydirect) > minSide && targetx - targetsize - size/2 * Math.abs(ydirect) < maxSide && targety + targetsize + size * Math.abs(xdirect) > minSide2 && targety - targetsize - size * Math.abs(xdirect) < maxSide2 && targety + targetsize + size * Math.abs(xdirect) > expectedYMulti + y1 && targety - targetsize - size * Math.abs(xdirect) < expectedYMulti + y1;
        }
        function onCritEffects(impactx, impacty){
            if(Math.random() <= critShadowChance){
                extraShots++;
            }
            if(critAoeDuration > 0){
                skillIDCounter++;
                aoes.push(new circlecomponent(impactx, impacty, critAoeSize, ml/1000, 'cyan', 'cyan'));
                areass.push(new areasSideStats(critAoeDuration * 1000, critAoeDamage * playerDamage/50, 0, 'Player', false, false));
                aoeTrackerID.push(skillIDCounter);
                aoeCycler(aoes.length - 1);
            }
        }
        function onHitEffects(damage, enemyid, bulletid){
            heal(globalLifeSteal)
            if(fragmentBullets != 0 && bullProperties[bulletid].fragmenting == true){
                for(let i = 0; i < fragmentBullets; i++){
                    let aimX = Math.random();
                    let aimY = 1 - aimX;
                    if(randomInt(1, 2) == 1){
                        aimX *= -1;
                    }
                    if(randomInt(1, 2) == 1){
                        aimY *= -1;
                    }
                    let bouncy = false;
                    let piercing = false;
                    if(Math.random() < bounceChance){
                        bouncy = true;
                    }
                    if(Math.random() < pierceChance){
                        piercing = true;
                    }
                    bss.push(new bulletSideStats(aimX, aimY, damage * fragmentDamage, bulletSpeed, bulletDuration * bulletDurationMulti, "Player"));
                    bullets.push(new squarecomponent(bulletSize, bulletSize, enemies[enemyid].x, enemies[enemyid].y, "white", "cyan"));
                    bullProperties.push(new bulletProperties(looperBullets, bouncy, bounceTimes, recursiveFragments, piercing));
                    bulletTrackerID.push(bulletCounter);
                    bulletCounter++;
                    bss[bss.length - 1].interacting.push(enemyTrackerID[enemyid]);
                }
            }
            if(damage >= playerDamage * largeDamageThreshold){
                laregeDamageEffects()
            }
        }
        function laregeDamageEffects(){
            heal(largeDamageHealing)
        }
        function sideHandler(id, size){
            if(bullProperties[id].looping == true || bullProperties[id].bouncing == true && bullProperties[id].bouncesLeft > 0){
                if(bullProperties[id].bouncing == true && bullProperties[id].bouncesLeft != 0){
                    if(bullets[id].y - ml/2000 * size > c.height || bullets[id].y + ml/2000 * size < 0){
                        bss[id].ymom *= -1;
                        bullProperties[id].bouncesLeft--;
                    } else if(bullets[id].x + ml/2000 * size < 0 || bullets[id].x - ml/2000 * size > c.width){
                        bss[id].xmom *= -1;
                        bullProperties[id].bouncesLeft--;
                    }
                } else if (bullProperties[id].looping == true){
                    if(bullets[id].x - ml/2000 * size > c.width){
                        bullets[id].x = 0 + ml/2000 * size;
                    } else if(bullets[id].x + ml/2000 * size < 0){
                        bullets[id].x = c.width - ml/size/2;
                    }
                    if(bullets[id].y - ml/2000 * size > c.height){
                        bullets[id].y = 0 + ml/2000 * size;
                    } else if(bullets[id].y + ml/2000 * size < 0){
                        bullets[id].y = c.height - ml/size/2;
                    }
                }
            } else{
                if(bullets[id].x + ml/2000 * size < 0 || bullets[id].x - ml/2000 * size > c.width || bullets[id].y + ml/2000 * size < 0 || bullets[id].y - ml/2000 * size > c.height){
                    markedBullets.push(bulletTrackerID[id]);
                }
            }
        }
        function damagePlayer(damage, damageType){
            damageTime = 0;
            let damagedealt = damage * damageReduction * globalEnemyDamage
            switch(damageType){
                case "DOT":
                    damagedealt *= dotDamageReduction;
                    currentDCH = 0;
                    storedDCH = 0;
                    storedRammingHP += -rammingLosses;
                    break;
                case "Projectile":
                    damagedealt *= projectileDamageReduction;
                    currentDCH = 0;
                    storedDCH = 0;
                    storedRammingHP += -rammingLosses;
                    break;
                case "Contact": 
                    if(killTime < rammingImmunityTime * 50 || lastKillType !== "Ramming"){
                        damagedealt *= contactDamageReduction * movingContactReduction
                    } else{
                        damagedealt = 0;
                    }
                    currentDCH = damage * delayedContactHealing * globalEnemyDamage;
                    storedDCH = currentDCH;
                    break;
            }
            if(shield > 0){
                let tempshieldvalue = shield
                shield -= damagedealt
                damagedealt -= tempshieldvalue
                if(damagedealt < 0){
                    damagedealt = 0
                }
                if(shield <= 0){
                    shield = 0
                    shieldBreakEffects()
                }
            }
            health -= damagedealt
            if(storedRammingHP <= 0){
                storedRammingHP == 0;
            }
            if(health > 0){
                if(damageType != "DOT"){
                    if(damageType == "Contact"){
                        iframeCycler(rammingIframes);
                    } else{
                        iframeCycler(projectileIframes);
                    }
                }
            }
        }
        function shieldBreakEffects(){
            if (shieldBreakAoeDamage > 0){
                skillIDCounter++;
                aoes.push(new circlecomponent(character.x, character.y, shieldBreakAoeSize, ml/1000, 'cyan', 'cyan'));
                areass.push(new areasSideStats(shieldBreakAoeDuration, shieldBreakAoeDamage * playerDamage/50, 0, 'Player', false, false));
                aoeTrackerID.push(skillIDCounter);
                aoeCycler(aoes.length - 1);
            }
        }
        function bulletDestroy(id){
            bullets.splice(id, 1);
            bss.splice(id, 1);
            bullProperties.splice(id, 1);
            bulletTrackerID.splice(id, 1);
        }
        function onKillEffects(){
            if(deathBurstDuration != 0){
                playerBuffs.deathBurst = deathBurstDuration;
            }
            if(deathMissleDamage != 0 && enemies.length != 0){
                let tempDistance = Infinity;
                let tempTarget;
                for(let i = 0; i < enemies.length; i++){
                    let currentDistance = distanceCalc(character.x, character.y, enemies[i].x, enemies[i].y);
                    if(currentDistance < tempDistance){
                        tempDistance = currentDistance;
                        tempTarget = i;
                    }
                }
                let tempAimer = new aimer(character.x, character.y, enemies[tempTarget].x, enemies[tempTarget].y);
                playerShoot(tempAimer.x, tempAimer.y, deathMissleDamage);
            }
        }
        function playerShoot(aimx, aimy, damagemulti){
            let bouncy = false;
            let piercing = false;
            if(Math.random() < bounceChance){
                bouncy = true;
            }
            if(Math.random() < pierceChance){
                piercing = true;
            }
            if(shotSpread != 0){
                let shotAngle = Math.atan2(aimx, aimy) * 180/Math.PI + randomInt(-shotSpread, shotSpread);
                aimx = Math.sin(shotAngle/180 * Math.PI)
                aimy = Math.cos(shotAngle/180 * Math.PI)
            }
            bss.push(new bulletSideStats(aimx, aimy, playerDamage * damagemulti, bulletSpeed, bulletDuration * bulletDurationMulti, "Player"));
            bullets.push(new squarecomponent(bulletSize, bulletSize, character.x, character.y, "white", "cyan"));
            bullProperties.push(new bulletProperties(looperBullets, bouncy, bounceTimes, true, piercing));
            bulletTrackerID.push(bulletCounter);
            bulletCounter++;
        }
        function killChecker(id, type){
            ess[id].healthBarCounter = 100;
            if(ess[id].hp <= 0){
                lastKillType = type;
                xp += enemyStatBlock[ess[id].type].reward * xpGain * multiplicativeXpGain;
                totalXP += enemyStatBlock[ess[id].type].reward * xpGain * multiplicativeXpGain;
                if(xp >= requiredXP){
                    levelUp();
                }
                for(let i = 0; i < lasers.length; i++){
                    if(lss[i].eoti == enemyTrackerID[id]){
                        laserDestroy(i);
                        i--;
                    }
                }
                for(let i = 0; i < aoes.length; i++){
                    if(areass[i].eoti == enemyTrackerID[id]){
                        aoeDestroy(i);
                        i--;
                    }
                }
                enemies.splice(id, 1);
                ess.splice(id, 1);
                enemyTrackerID.splice(id, 1);
                enemyCount--;
                kills++;
                onKillEffects()
                killTime = 0;
                if(enemyCount == 0 && spawnFinish == true){
                    waveActive = false;
                    shield = maxShield
                    enemyWaveCounter = 0;
                    heal(storedRammingHP);
                    storedRammingHP = 0;
                    bulletCounter = 0;
                    bullets.length = 0;
                    bss.length = 0;
                    bulletTrackerID.length = 0;
                    bullProperties.length = 0;
                    director();
                }
            }
        }
        function levelUp(){
            let overflow = xp - requiredXP;
            requiredXP = requiredXP * xpGrowth;
            xp = overflow;
            heal(levelRegen);
            skillPoints++;
            level++;
            if(health == maxHealth){
                health += maxHpPerLevel;
                maxHealth += maxHpPerLevel;
            } else{
                heal(maxHpPerLevel);
            }
            if(level % 5 == 0){
                skillPoints += additionalSkillPoints;
            }
            if(xp >= requiredXP){
                levelUp();
            }
        }
        if(xp > requiredXP){
            levelUp();
        }
        function ai(target, targetid){
            let mover = new aimer(target.x, target.y, character.x, character.y);
            let distance = distanceCalc(target.x, target.y, character.x, character.y);
            let random = Math.random();
            const type = enemyStatBlock[ess[targetid].type];
            let moverai = type.moveai;
            let shooterai = type.shotai;
            let skillai = type.skill;
            if(ess[targetid].skillactive.length == 0 || type.skillMove == true){
                if(ess[targetid].shooting == false || type.shootMove == true){
                    switch(moverai){
                        case "Converge":
                            target.x += mover.x * type.speed * ml/1000;
                            target.y += mover.y * type.speed * ml/1000;
                            break;
                        case "Follow":
                            if(distance > ml * type.followDistance + type.speed * ml/2000){
                                target.x += mover.x * type.speed * ml/1000;
                                target.y += mover.y * type.speed * ml/1000;
                            } else if (distance < ml * type.followDistance - type.speed * ml/1000){
                                target.x += -mover.x * type.speed * ml/1000;
                                target.y += -mover.y * type.speed * ml/1000;
                            }
                            break;
                        case "X-Y":
                            if(ess[targetid].randomChooser == 1){
                                if(target.x + type.speed * ml/1000 > character.x && target.x - type.speed * ml/1000 < character.x){
                                    target.y += Math.sign(mover.y) * type.speed * ml/1000;
                                } else{
                                    target.x += Math.sign(mover.x) * type.speed * ml/1000;
                                }
                            } else{
                                if(target.y + type.speed * ml/1000 > character.y && target.y - type.speed * ml/1000 < character.y){
                                    target.x += Math.sign(mover.x) * type.speed * ml/1000;
                                } else{
                                    target.y += Math.sign(mover.y) * type.speed * ml/1000;
                                }
                            }
                            break;
                    }
                }
            }
            if(ess[targetid].shotavailable == true){
                enemyShotCycler(targetid);
                enemyShotSequence(target, targetid, type);
            }
            if(ess[targetid].skillavailable == true){
                enemySkillCycler(targetid);
                let tempXOrigin;
                let tempYOrigin;
                skillIDCounter++;
                ess[targetid].skillactive.push(true);
                switch(type.skillOrigin){
                    case "Dynamic":
                    case "Static":
                        tempXOrigin = target.x;
                        tempYOrigin = target.y;
                        break;
                    case "Center":
                        tempXOrigin = c.width/2;
                        tempYOrigin = c.height/2;
                        break
                    case "SetRandom":
                        tempXOrigin = ess[targetid].randomPosX * c.width;
                        tempYOrigin = ess[targetid].randomPosY * c.height;
                        break;
                    case "SideRandom":
                        switch(randomInt(1, 4)){
                            case 1:
                                tempXOrigin = Math.random() * c.width;
                                tempYOrigin = c.height;
                                break;
                            case 2:
                                tempXOrigin = Math.random() * c.width;
                                tempYOrigin = 0;
                                break;
                            case 3:
                                tempXOrigin = 0;
                                tempYOrigin = Math.random() * c.height;
                                break;
                            case 4:
                                tempXOrigin = c.width;
                                tempYOrigin = Math.random() * c.height;
                                break;
                        }
                        break;
                    case "TrueRandom":
                        tempXOrigin = Math.random() * c.width;
                        tempYOrigin = Math.random() * c.height;
                        break;
                }
                switch(skillai){
                    case "Laser":
                        let tempAngle = 0;
                        let tempLaserAimer = new aimer(tempXOrigin, tempYOrigin, character.x, character.y);
                        switch(type.laserType){
                            case "Sweep":
                                tempAngle = Math.atan2(tempLaserAimer.x, tempLaserAimer.y) - type.sweepPrecision/180 * Math.PI;
                                break;
                            case "Predict":
                                let TempPredictAimer = new aimer(tempXOrigin, tempYOrigin, character.x + ml/1000 * playerXDirect * playerSpeed * type.predictPrecision/20, character.y + ml/1000 * playerYDirect * playerSpeed * type.predictPrecision/20);
                                tempAngle = Math.atan2(TempPredictAimer.x, TempPredictAimer.y);
                                break;
                            case "Random":
                                tempAngle = randomInt(0, 360)/180 * Math.PI;
                                break;
                        }
                        lss.push(new laserSideStats(type.skillDuration, type.damage, type.laserLength, enemyTrackerID[targetid], Math.sin(tempAngle), Math.cos(tempAngle), type.skillOrigin, type.laserType, tempAngle));
                        lasers.push(new linecomponent(tempXOrigin, tempYOrigin, Math.sin(tempAngle) * type.laserLength * ml/1000, Math.cos(tempAngle) * type.laserLength * ml/1000, type.laserSize, type.effectsColor, type.effectsGlowColor));
                        laserTrackerID.push(skillIDCounter);
                        if(type.laserType != "Sweep"){
                            laserCycler(lasers.length - 1);
                        }
                        break;
                    case "AOE":
                        aoes.push(new circlecomponent(tempXOrigin, tempYOrigin, type.aoeSize, type.aoeWidth, type.effectsColor, type.effectsGlowColor));
                        areass.push(new areasSideStats(type.skillDuration, type.damage * type.aoeDamage, type.aoeHealing, enemyTrackerID[targetid], type.damageConsume, type.healConsume));
                        aoeTrackerID.push(skillIDCounter);
                        aoeCycler(aoes.length - 1);
                        break;
                }
            }
            if(target.x < 0){
                target.x = 0;
            } else if (target.x > c.width){
                target.x = c.width;
            }
            if(target.y < 0){
                target.y = 0;
            } else if (target.y > c.height){
                target.y = c.height;
            }
        }
        async function enemyShotSequence(target, targetid, type){
            let shooterai = type.shotai;
            let trackerID = enemyTrackerID[targetid];
            ess[targetid].shooting = true;
            let mover = new aimer(target.x, target.y, character.x, character.y);
            let distance = distanceCalc(target.x, target.y, character.x, character.y);
            let charaAngle = Math.atan2(mover.x, mover.y) * 180/Math.PI;
            let finalAimerX;
            let finalAimerY;
            totalRunner: for(let t = 0; t < type.shotIterations; t++){
                if(type.iterationsDelay != 0){
                    await sleep(type.iterationsDelay)
                }
                for(let i = 0; i < type.burst; i++){
                    switch(shooterai){
                        case "DirectedAngle":
                            ess[targetid].shotAngle = charaAngle - type.angleOffset + type.angleOffset/type.cycleCount * (ess[targetid].cycleCount + 0.5) * 2;
                            ess[targetid].cycleCount++;
                            if(ess[targetid].cycleCount >= type.cycleCount){
                                ess[targetid].cycleCount = 0;
                            }
                        case "UndirectedAngle":
                            finalAimerX = Math.sin(ess[targetid].shotAngle * Math.PI/180);
                            finalAimerY = Math.cos(ess[targetid].shotAngle * Math.PI/180);
                            break;
                        case "Basic":
                            finalAimerX = mover.x;
                            finalAimerY = mover.y;
                            break;
                        case "Random":
                            let quadrant = randomInt(1, 4);
                            let randomNum = Math.random();
                            switch(quadrant){
                                case 1:
                                    finalAimerX = randomNum;
                                    finalAimerY = 1 - randomNum;
                                    break;
                                case 2:
                                    finalAimerX = -randomNum;
                                    finalAimerY = 1 - randomNum;
                                    break;
                                case 3:
                                    finalAimerX = randomNum;
                                    finalAimerY = randomNum - 1
                                    break;
                                case 4:
                                    finalAimerX = -randomNum;
                                    finalAimerY = randomNum - 1;
                                    break;
                            }
                            break;
                        case "Predictive":
                            if(playerXDirect == 0 && playerYDirect == 0){
                                finalAimerX = mover.x;
                                finalAimerY = mover.y;
                            } else{
                                let closeLevel = distance;
                                let targetPosX = character.x;
                                let targetPosY = character.y;
                                for(let i = 0; i < 250; i++){
                                    let predictedX = character.x + playerXDirect * ml/1000 * playerSpeed * i;
                                    let predictedY = character.y + playerYDirect * ml/1000 * playerSpeed * i;
                                    let predictAimer = new aimer(target.x, target.y, predictedX, predictedY);
                                    if(predictedX < -ml/300 || predictedX > c.width + ml/300 || predictedY < -ml/300 || predictedY > c.height + ml/300){
                                        break;
                                    }
                                    let adjustedBulletX = target.x + predictAimer.x * ml/1000 * type.projectileSpeed * i;
                                    let adjustedBulletY = target.y + predictAimer.y * ml/1000 * type.projectileSpeed * i;
                                    let predictedCloseness = distanceCalc(adjustedBulletX, adjustedBulletY, predictedX, predictedY);
                                    if(predictedCloseness < closeLevel){
                                        closeLevel = predictedCloseness;
                                        targetPosX = predictedX;
                                        targetPosY = predictedY;
                                    }
                                    if(predictedCloseness < ml/1000 * type.projectileSpeed){
                                        break;
                                    }
                                }
                                let finalAimer = new aimer(target.x, target.y, targetPosX, targetPosY);
                                finalAimerX = finalAimer.x;
                                finalAimerY = finalAimer.y;
                            }
                            break;                
                    }
                    if(enemyTrackerID.indexOf(trackerID) !== -1){
                        bss.push(new bulletSideStats(finalAimerX, finalAimerY, type.damage * type.projectileDamage, type.projectileSpeed, type.projectileDuration, "Enemy"));
                        bulletTrackerID.push(bulletCounter);
                        bullProperties.push(type.projectileProperties);
                        bullets.push(new squarecomponent(type.projectileSize, type.projectileSize, target.x, target.y, type.effectsColor, type.effectsGlowColor));
                        bulletCounter++;
                    } else{
                        break totalRunner;
                    }
                    if(type.burstDelay != 0){
                        await sleep(type.burstDelay); 
                    }
                    if(type.burstChange == true && shooterai == "UndirectedAngle"){
                        ess[targetid].shotAngle += (type.shotMaxAngle - type.shotMinAngle)/type.cycleCount;
                        if(ess[targetid].shotAngle > type.shotMaxAngle){
                            ess[targetid].shotAngle = type.shotMinAngle;
                        }
                    }
                }
                if(type.burstChange == false && shooterai == "UndirectedAngle"){
                    ess[targetid].shotAngle += (type.shotMaxAngle - type.shotMinAngle)/type.cycleCount;
                    if(ess[targetid].shotAngle > type.shotMaxAngle){
                        ess[targetid].shotAngle = type.shotMinAngle;
                    }
                }
            }
            if(enemyTrackerID.indexOf(trackerID) !== -1){
                ess[targetid].shooting = false;
            } 
        }
        function render(){
            cx.globalAlpha = standardAlpha;
            cx.clearRect(0, 0, c.width, c.height);
            cx.shadowBlur = 8;
            for(let i = 0; i < bullets.length; i++){
                if(bss[i].owner == "Player"){
                    cx.globalAlpha = standardAlpha;
                    prop = bullProperties[i];
                    if(prop.cycler > 2){
                        prop.cycler = 1;
                    }
                    switch(prop.cycler){
                        case 1:
                            if(prop.bouncing == true){
                                bullets[i].color = "blue";
                            }
                            break;
                        case 2:
                            if(prop.piercing == true){
                                bullets[i].color = "#FFFF00";
                            }
                            break;
                            
                    }
                    bullets[i].update();
                    prop.cycler++;
                }
            }
            cx.globalAlpha = standardAlpha;
            for(let i = 0; i < aoes.length; i++){
                aoes[i].update();
            }
            for(let i = 0; i < enemies.length; i++){
                let type = enemyStatBlock[ess[i].type];
                enemies[i].update();
                if(ess[i].healthBarCounter > 0){
                    if(ess[i].healthBarCounter > 50){
                        cx.globalAlpha = standardAlpha;
                    } else{
                        cx.globalAlpha = standardAlpha * ess[i].healthBarCounter/50;
                    }
                    cx.strokeStyle = "gray";
                    cx.shadowColor = "gray";
                    cx.lineWidth = ml/1000;
                    cx.strokeRect(enemies[i].x - ml/2000 * enemies[i].width * 0.85, enemies[i].y - ml/2000 * enemies[i].height * 1.5, ml/1000 * enemies[i].width * 0.8, ml/10000 * enemies[i].height);
                    if(ess[i].healthBarCounter <= 100){
                        cx.fillStyle = type.effectsColor;
                        cx.shadowColor = type.effectsGlowColor;
                    } else{
                        cx.fillStyle = "green";
                        cx.shadowColor = "lime";
                    }
                    cx.fillRect(enemies[i].x - ml/2000 * enemies[i].width * 0.85, enemies[i].y - ml/2000 * enemies[i].height * 1.5, ml/1000 * enemies[i].width * 0.8 * ess[i].hp/(type.hp * globalEnemyHP), ml/10000 * enemies[i].height);
                    cx.globalAlpha = standardAlpha;
                }
                if(ess[i].skillactive.length != 0){
                    cx.strokeStyle = type.effectsColor;
                    cx.shadowColor = type.effectsGlowColor;
                    cx.lineWidth = ml/400;
                    cx.beginPath();
                    cx.arc(enemies[i].x, enemies[i].y, ml/enemies[i].width/3, 0, Math.PI * 2);
                    cx.stroke();
                    cx.closePath();
                }
            }
            for(let i = 0; i < lasers.length; i++){
                lasers[i].update();
            }
            for(let i = 0; i < bullets.length; i++){
                if(bss[i].owner != "Player"){
                    bullets[i].update();
                }
            }
            if(invulnerable == true){
                cx.globalAlpha = standardAlpha * 0.1;
            }
            character.update();
            cx.globalAlpha = standardAlpha;
            cx.textAlign = "center";
            if(waveActive == false){
                cx.fillStyle = "darkslateblue";
                cx.shadowColor = "cyan";
                cx.fillRect(0, c.height * 0.005, c.width/waveDelay/50 * waveDelayCounter, ml/500);
                if(pause == false){
                    cx.strokeStyle = "white";
                    cx.font = ml/20 + "px Arial";
                    cx.lineWidth = ml/400;
                    cx.strokeText("Press Z to Procede", c.width * 0.8, c.height * 0.1);
                    cx.strokeText("Press E for Inventory", c.width * 0.8, c.height * 0.2);
                }
            } else{
                cx.fillStyle = "darkred";
                cx.shadowColor = "red";
                let totalCredits = baseCredits + (wave - 1) * directorCreditMulti;
                cx.fillRect(0, c.height * 0.005, c.width/totalCredits * (totalCredits - directorCredits), ml/500);
            }
            cx.globalAlpha = standardAlpha;
            cx.strokeStyle = "red";
            cx.shadowColor = "pink";
            cx.font = ml/20 + "px Arial";
            cx.lineWidth = ml/1200;
            cx.strokeText(parseFloat(health.toFixed(2)) + "/" + maxHealth + " HP", c.width/2, c.height * 0.07);
            if(maxShield > 0){
                cx.strokeStyle = "blue";
                cx.shadowColor = "blue";
                cx.font = ml/70 + "px Arial";
                cx.strokeText(parseFloat(shield.toFixed(2)) + "/" + maxShield + " Shield", c.width/2, c.height * 0.1);
            }
            cx.strokeStyle = "white";
            cx.font = ml/40 + "px Arial";
            cx.strokeText('Wave: ' + wave, c.width/2, c.height * 0.15)
            cx.shadowColor = "cyan";
            cx.globalAlpha = 1;
            cx.strokeRect(0, c.height * 0.995, c.width/requiredXP * xp, ml/500);
            if(skillPoints != 0){
                if(waveActive == true){
                    cx.globalAlpha = 0.1;
                } else{
                    cx.globalAlpha = 1;
                }
                cx.strokeText(skillPoints + " Unspent Point(s) Remaining", c.width/2, c.height * 0.95);
                cx.globalAlpha = standardAlpha;
            }
            function inventory(){
                cx.globalAlpha = 1;
                let tempxoffset = 0;
                for (let i = 0; i < purchasedItems.length; i++){
                    if(i % mlhr == 0 && i != 0){
                        tempxoffset++;
                    }
                    cx.shadowColor = purchasedItems[i].boxGlowStyle;
                    cx.strokeStyle = purchasedItems[i].boxStyle;
                    cx.lineWidth = ml/1000;
                    let xpos = ml/30 * tempxoffset;
                    let ypos =  ml/40 * (i - tempxoffset * mlhr) + ml/100;
                    cx.strokeRect(xpos, ypos, ml * 0.02, ml * 0.02);
                    purchasedItems[i].icon(xpos, ypos, 0.2);
                    let target = totalItemList[purchasedItems[i].trackerID]
                    if(target.purchased > 1){
                        if(target.purchased == target.maxPurchases){
                            cx.shadowColor = 'gold';
                            cx.strokeStyle = 'gold';
                        } else{
                            cx.shadowColor = 'white';
                            cx.strokeStyle = 'white';
                        }
                        cx.font = ml/100 + "px Arial";
                        cx.lineWidth = ml/2000;
                        cx.strokeText("X" + target.purchased, xpos + ml * 0.02, ypos + ml * 0.005);
                    }
                }
            }
            if(pause == true){
                cx.globalAlpha = 1;
                inventory()
                cx.shadowColor = "blue";
                cx.strokeStyle = "white";
                cx.font = ml/30 + "px Arial";
                cx.lineWidth = ml/600;
                cx.strokeText("Level: " + level, c.width/2, c.height * 0.06);
                cx.font = ml/50 + "px Arial";
                cx.lineWidth = ml/1000;
                cx.strokeText(rerolls + " Reroll(s) Left", c.width/2, c.height * 0.1);
                cx.fillStyle = "gray";
                cx.fillRect(c.width * 0.45, c.height * 0.15, c.width * 0.1, c.height * 0.05);
                cx.strokeText("Reroll (R)", c.width/2, c.height * 0.185);
                cx.fillStyle = "black";
                cx.shadowColor = "white";
                cx.fillRect(c.width * 0.7, c.height * 0.05, c.width * 0.25, c.height * 0.9);
                cx.lineWidth = ml/2000;
                cx.strokeStyle = "darkslateblue";
                cx.shadowColor = "cyan";
                cx.strokeRect(c.width * 0.7, c.height * 0.05, c.width * 0.25, c.height * 0.9);
                cx.lineWidth = ml/1000;
                if (offeredItems[0] !== undefined){
                    cx.shadowColor = offeredItems[0].boxGlowStyle;
                    cx.strokeStyle = offeredItems[0].boxStyle;
                } else{
                    cx.shadowColor = 'blue';
                    cx.strokeStyle = 'cyan'
                }
                cx.strokeRect(c.width * 0.45 - ml * 0.1, c.height * 0.3, ml * 0.1, ml * 0.1);
                if (offeredItems[1] !== undefined){
                    cx.shadowColor = offeredItems[1].boxGlowStyle;
                    cx.strokeStyle = offeredItems[1].boxStyle;
                } else{
                    cx.shadowColor = 'blue';
                    cx.strokeStyle = 'cyan'
                }
                cx.strokeRect(c.width * 0.55, c.height * 0.3, ml * 0.1, ml * 0.1);
                if (offeredItems[2] !== undefined){
                    cx.shadowColor = offeredItems[2].boxGlowStyle;
                    cx.strokeStyle = offeredItems[2].boxStyle;
                } else{
                    cx.shadowColor = 'blue';
                    cx.strokeStyle = 'cyan'
                }
                cx.strokeRect(c.width * 0.45 - ml * 0.1, c.height * 0.6, ml * 0.1, ml * 0.1);
                if (offeredItems[3] !== undefined){
                    cx.shadowColor = offeredItems[3].boxGlowStyle;
                    cx.strokeStyle = offeredItems[3].boxStyle;
                } else{
                    cx.shadowColor = 'blue';
                    cx.strokeStyle = 'cyan'
                }
                cx.strokeRect(c.width * 0.55, c.height * 0.6, ml * 0.1, ml * 0.1);
                for(let i = 0; i < 4; i++){
                    if(offeredItems[i] !== undefined){
                        let xpos;
                        let ypos;
                        switch(i){
                            case 0:
                                xpos = c.width * 0.45 - ml * 0.1;
                                ypos = c.height * 0.3;
                                break;
                            case 1:
                                xpos = c.width * 0.55;
                                ypos = c.height * 0.3;
                                break;
                            case 2:
                                xpos = c.width * 0.45 - ml * 0.1;
                                ypos = c.height * 0.6;
                                break;
                            case 3:
                                xpos = c.width * 0.55;
                                ypos = c.height * 0.6;  
                                break;
                        }
                        offeredItems[i].icon(xpos, ypos, 1)
                    }
                }
                if(inspectingTarget != 0){
                    if(inspectingTarget == 1 && offeredItems[inspecting - 1] !== undefined){
                        descriptionHandler(offeredItems[inspecting - 1]);
                    } else if (inspectingTarget == 2){
                        descriptionHandler(purchasedItems[inspecting]);
                    }
                }
                cx.fillStyle = "white";
                cx.shadowColor = "white";
                cx.globalAlpha = 0.1;
                if(inspectingTarget == 1){
                    switch(inspecting){
                        case 1:
                            cx.fillRect(c.width * 0.45 - ml * 0.1, c.height * 0.3, ml * 0.1, ml * 0.1);
                            break;
                        case 2:
                            cx.fillRect(c.width * 0.55, c.height * 0.3, ml * 0.1, ml * 0.1);
                            break;
                        case 3:
                            cx.fillRect(c.width * 0.45 - ml * 0.1, c.height * 0.6, ml * 0.1, ml * 0.1);
                            break;
                        case 4:
                            cx.fillRect(c.width * 0.55, c.height * 0.6, ml * 0.1, ml * 0.1);
                            break;
                    }
                } else if (inspectingTarget == 2){
                    cx.fillRect(ml/30 * Math.floor(inspecting/mlhr), ml/40 * (inspecting - Math.floor(inspecting/mlhr) * mlhr) + ml/100, ml/50, ml/50);
                } else if (inspectingTarget == 3){
                    cx.fillRect(c.width * 0.45, c.height * 0.15, c.width * 0.1, c.height * 0.05);
                    cx.strokeStyle = "white";
                    cx.shadowColor = "cyan";
                    cx.globalAlpha = 1;
                    cx.lineWidth = ml/1000;
                    cx.strokeText("Reroll", c.width * 0.825, c.height * 0.1);
                    cx.strokeText("Consume one reroll in", c.width * 0.825, c.height * 0.17);
                    cx.strokeText("order to gain a new set", c.width * 0.825, c.height * 0.22);
                    cx.strokeText("of offererd items without", c.width * 0.825, c.height * 0.27);
                    cx.strokeText("spending a skillpoint.", c.width * 0.825, c.height * 0.32);
                    cx.strokeText("You gain one reroll every", c.width * 0.825, c.height * 0.37);
                    cx.strokeText("3 waves.", c.width * 0.825, c.height * 0.42);
                    cx.shadowColor = "red";
                    if(rerolls <= 0){
                        cx.strokeText("No rerolls remaining!", c.width * 0.825, c.height * 0.47);
                    }
                }
            }
            if(gameOver == true){
                inventory();
                cx.strokeStyle = "white";
                cx.shadowColor = "cyan";
                cx.font = ml/10 + "px Arial";
                cx.lineWidth = ml/400;
                cx.strokeText('Game Over', c.width/2, c.height * 0.3);
                cx.font = ml/30 + 'px Arial';
                cx.lineWidth = ml/1200;
                cx.strokeText('Enemies Killed: ' + kills, c.width/2, c.height * 0.4);
                cx.strokeText('Total XP Gained: ' + parseFloat(totalXP.toFixed(1)), c.width/2, c.height * 0.48);
                cx.strokeText('Level Achieved: ' + level, c.width/2, c.height * 0.56);
                cx.shadowColor = "yellow";
                cx.strokeText('Press R to Restart', c.width/2, c.height * 0.64);
            }
        }
        function descriptionHandler(target){
            cx.font = c.width/75 + "px Arial";
            cx.lineWidth = ml/1000;
            cx.textAlign = "center";
            cx.strokeStyle = target.nameColor;
            cx.shadowColor = target.nameGlowColor;
            cx.strokeText(target.name, c.width * 0.825, c.height * 0.1);
            cx.strokeStyle = "white";
            cx.shadowColor = "cyan";
            let offset = 0;
            let cycles = 0;
            let description = target.description()
            for(let t = 0; t < description.length; t++){
                offset = 0;
                for(let i = 0; i <= description[t].length; i++){
                    if(description[t].charAt(i) == " " && i - offset > 25 || i == description[t].length){
                        cycles++;
                        cx.strokeText(description[t].substr(offset, i - offset), c.width * 0.825, c.height * (0.12 + 0.05 * cycles));
                        offset = i;
                    }
                }
            }
            if(skillPoints <= 0 && inspectingTarget == 1){
                cx.shadowColor = "red";
                cx.strokeText("No skillpoints remaining!", c.width * 0.825, c.height * (0.12 + 0.05 * (cycles + 1)));
            }
        }
        function squarecomponent(width, height, x, y, color, glowcolor){
            this.width = width;
            this.height = height;
            this.originalWidth = width;
            this.originalHeight = height;
            this.x = x;
            this.y = y;
            this.glowcolor = glowcolor;
            this.color = color;
            this.update = function(){
                cx.fillStyle = this.color;
                cx.shadowColor = this.glowcolor;
                cx.fillRect(this.x - ml/2000 * this.width, this.y - ml/2000 * this.height, ml/1000 * this.width, ml/1000 * this.height);
            }
        }
        function linecomponent(startx, starty, endx, endy, size, color, glowcolor){
            this.size = size;
            this.startx = startx;
            this.starty = starty;
            this.endx = endx;
            this.endy = endy;
            this.color = color;
            this.glowcolor = glowcolor;
            this.update = function(){
                cx.strokeStyle = this.color;
                cx.shadowColor = this.glowcolor;
                cx.lineWidth = this.size * ml/1000;
                cx.beginPath();
                cx.moveTo(this.startx, this.starty);
                cx.lineTo(this.endx, this.endy);
                cx.stroke();
                cx.closePath();
            }
        }
        function circlecomponent(x, y, radius, width, color, glowcolor){
            this.x = x;
            this.y = y;
            this.r = radius;
            this.width = width;
            this.color = color;
            this.glowcolor = glowcolor;
            this.update = function(){
                cx.strokeStyle = this.color;
                cx.shadowColor = this.glowcolor;
                cx.lineWidth = this.width * ml/1000;
                cx.beginPath();
                cx.arc(this.x, this.y, this.r * ml/1000, 0, Math.PI * 2);
                cx.stroke();
            }
        }
        function sleep(ms){
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        async function shotCycler(){
            shotAvailable = false;
            totalDelay = shotDelay
            if(playerBuffs.deathBurst >= 0){
                totalDelay /= deathBurstIncrease
            }
            if(shield > 0){
                totalDelay /= shieldAttackSpeedBonus
            }
            if(extraShots <= 0){
                await sleep(totalDelay);
                if(randomInt(0, 100) < extraShotChance){
                    extraShots++;
                }
            } else{
                extraShots--;
            }
            shotAvailable = true;
        }
        shotCycler();
        async function iframeCycler(multi){
            invulnerable = true;
            await sleep(iframes * multi);
            invulnerable = false;
        }
        async function enemyShotCycler(enemyID){
            ess[enemyID].shotavailable = false;
            let trackerID = enemyTrackerID[enemyID];
            await sleep(enemyStatBlock[ess[enemyID].type].shotDelay);
            if(enemyTrackerID.indexOf(trackerID) !== -1){
                ess[enemyTrackerID.indexOf(trackerID)].shotavailable = true;
            }
        }
        async function enemySkillCycler(enemyID){
            ess[enemyID].skillavailable = false;
            let trackerID = enemyTrackerID[enemyID];
            await sleep(enemyStatBlock[ess[enemyID].type].skillDelay);
            if(enemyTrackerID.indexOf(trackerID) !== -1){
                ess[enemyTrackerID.indexOf(trackerID)].skillavailable = true;
            }
        }
        async function laserCycler(laserID){
            let trackerID = laserTrackerID[laserID];
            await sleep(lss[laserID].duration);
            if(laserTrackerID.indexOf(trackerID) !== -1){
                laserDestroy(laserTrackerID.indexOf(trackerID));
            }
        }
        async function aoeCycler(aoeID){
            let trackerID = aoeTrackerID[aoeID];
            await sleep(areass[aoeID].duration);
            if(aoeTrackerID.indexOf(trackerID) !== -1){
                aoeDestroy(aoeTrackerID.indexOf(trackerID))
            }
        }
        function aoeDestroy(id){
            if (areass[id].eoti != "Player"){
                ess[enemyTrackerID.indexOf(areass[id].eoti)].skillactive.splice(0, 1);
            }
            aoes.splice(id, 1);
            areass.splice(id, 1);
            aoeTrackerID.splice(id, 1);
        }
        function laserDestroy(id){
            ess[enemyTrackerID.indexOf(lss[id].eoti)].skillactive.splice(0, 1);
            lasers.splice(id, 1);
            lss.splice(id, 1);
            laserTrackerID.splice(id, 1);
        }
        function aimer(originX, originY, targetX, targetY){
            let totalDistance = distanceCalc(originX, originY, targetX, targetY);
            this.x = (targetX - originX)/totalDistance;
            this.y = (targetY - originY)/totalDistance;
        }
        function distanceCalc(originX, originY, targetX, targetY){
            return Math.abs(targetX - originX) + Math.abs(targetY - originY);
        }
        function enemySpawner(enemyID){
            let enemyStats = enemyStatBlock[enemyID];
            let enemyPosSwapper = randomInt(0, 3);
            if(enemyPosSwapper == 0){
                enemies.push(new squarecomponent(enemyStats.size, enemyStats.size, 0, Math.random() * c.height, enemyStats.color, enemyStats.glowcolor));
            } else if (enemyPosSwapper == 1){
                enemies.push(new squarecomponent(enemyStats.size, enemyStats.size, c.width, Math.random() * c.height, enemyStats.color, enemyStats.glowcolor));
            } else if (enemyPosSwapper == 2){
                enemies.push(new squarecomponent(enemyStats.size, enemyStats.size, Math.random() * c.width, 0, enemyStats.color, enemyStats.glowcolor));
            } else{
                enemies.push(new squarecomponent(enemyStats.size, enemyStats.size, Math.random() * c.width, c.height, enemyStats.color, enemyStats.glowcolor));
            }
            ess.push(new enemySideStats(enemyID, false, enemyStats.hp * globalEnemyHP, false));
            enemyTrackerID.push(enemyWaveCounter);
            if(enemyStats.shotai !== undefined){
                enemyShotCycler(enemies.length - 1);
            }
            if(enemyStats.skill !== undefined){
                enemySkillCycler(enemies.length - 1);
            }
            enemyWaveCounter++;
            enemyCount++;
        }
        function randomInt(min, max){
            return Math.round(Math.random() * (max - min) + min);
        }
        function heal(amount){
            if(health + amount >= maxHealth){
                health = maxHealth;
            } else{
                health += amount;
            }
        }
        function shieldHeal(amount){
            if(shield + amount >= maxShield){
                shield = maxShield;
            } else{
                shield += amount
            }
        }
        async function director(){
            if(waveActive == true)
            {   let choice = true;
                while(directorCredits >= minCost){
                    if(choice == true && enemyCount != 0){
                        await sleep(randomInt(baseSpawnTime, baseSpawnTime * 2)/directorAggression);
                    } else{
                        await sleep(100/directorAggression);
                    }
                    choice = false;
                    let enemyChooser = randomInt(1, (totalWeight - 1));
                    let weightTracker = 0;
                    for(let i = 0; i < availableEnemies.length; i++){
                        if(enemyChooser > weightTracker && enemyChooser <= weightTracker + availableEnemies[i].weight && directorCredits >= availableEnemies[i].cost && enemyCount < enemyCap){
                            directorCredits += -availableEnemies[i].cost;
                            enemySpawner(availableEnemies[i].trackerID);
                            choice = true;
                            break;
                        }
                        weightTracker += availableEnemies[i].weight;
                    }
                }
                directorCredits = 0;
                spawnFinish = true;
            } else{
                spawnFinish = false;
                waveDelayCounter = 0;
                while(waveDelayCounter < waveDelay * 50){
                    await sleep(100);
                }
                waveActive = true;
                wave++;
                damageTime = 0;
                heal(roundRegen);
                minCostCalc();
                if(wave % 3 == 0){
                    rerolls++;
                }
                directorAggression = 1 + (wave - 1) * 0.1;
                directorCredits = baseCredits + (wave - 1) * directorCreditMulti;
                globalEnemyDamage *= enemyDamageScaling;
                globalEnemyHP *= enemyHpScaling;
                director();
            }
        }
        director();
    </script>
</html>